
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/zhekagigs/golang_todo/cli/cli.go (90.4%)</option>
				
				<option value="file1">github.com/zhekagigs/golang_todo/cmd/main.go (62.5%)</option>
				
				<option value="file2">github.com/zhekagigs/golang_todo/frontend/frontend.go (34.4%)</option>
				
				<option value="file3">github.com/zhekagigs/golang_todo/internal/task.go (74.3%)</option>
				
				<option value="file4">github.com/zhekagigs/golang_todo/internal/taskHolder.go (97.6%)</option>
				
				<option value="file5">github.com/zhekagigs/golang_todo/internal/testutils.go (18.8%)</option>
				
				<option value="file6">github.com/zhekagigs/golang_todo/internal/utils.go (85.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cli

import (
        "bufio"
        "errors"
        "flag"
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        in "github.com/zhekagigs/golang_todo/internal"
)

type commands string

const (
        READ   commands = "read"
        CREATE commands = "create"
        UPDATE commands = "update"
        DELETE commands = "delete"
        EXIT   commands = "exit"
)

const (
        ExitCodeSuccess = 0
        ExitCodeError   = 1
)

type CLIApp interface {
        AppStarter(newTaskHolder func(diskPath string) *in.TaskHolder) (*in.TaskHolder, bool, int)
        RunTaskManagmentCLI(taskHolder *in.TaskHolder) int
}

type RealCLIApp struct {
}

func (cli *RealCLIApp) RunTaskManagmentCLI(taskHolder *in.TaskHolder) int <span class="cov8" title="1">{
        reader := bufio.NewReader(os.Stdin)
        for </span><span class="cov8" title="1">{
                displayCommands()
                cmd, taskId, err := parseCommand(reader)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        continue</span>
                }

                <span class="cov8" title="1">if exitCode := executeCommand(cmd, taskId, taskHolder, reader); exitCode != -1 </span><span class="cov8" title="1">{
                        return exitCode
                }</span>
        }
}

func (cli *RealCLIApp) AppStarter(newTaskHolder func(diskPath string) *in.TaskHolder) (*in.TaskHolder, bool, int) <span class="cov8" title="1">{
        fileName, savedTasks, isHelp, isExit, exitCode := ParseUserArg()
        if isHelp </span><span class="cov8" title="1">{
                return nil, isExit, exitCode
        }</span>
        <span class="cov8" title="1">PrintCLITitle(savedTasks)

        taskHolder, err := PopulateTaskHolder(fileName, savedTasks, newTaskHolder)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error populating task holder: %v\n", err)
                return nil, true, ExitCodeError
        }</span>
        <span class="cov8" title="1">return taskHolder, false, ExitCodeSuccess</span>
}

func PrintCLITitle(savedTasks []in.Task) <span class="cov8" title="1">{
        fmt.Println(in.BeerAscii())
        fmt.Printf("\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Microbrewery Tasks Application&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n\n")
        in.PrintTasks(os.Stdout, savedTasks...)
}</span>

func PopulateTaskHolder(fileName string, savedTasks []in.Task, newTaskHolder func(diskPath string) *in.TaskHolder) (*in.TaskHolder, error) <span class="cov8" title="1">{
        if fileName == "" </span><span class="cov0" title="0">{
                fileName = "resources/disk.json"
        }</span>
        <span class="cov8" title="1">taskHolder := newTaskHolder(fileName)
        for _, task := range savedTasks </span><span class="cov8" title="1">{
                taskHolder.Add(task)
        }</span>
        <span class="cov8" title="1">return taskHolder, nil</span>
}

func ParseUserArg() (fileName string, savedTasks []in.Task, isHelp bool, isExit bool, exitCode int) <span class="cov8" title="1">{
        helpFlag := flag.Bool("h", false, "Help is here")

        flag.Usage = PrintHelp

        flag.Parse()

        if *helpFlag </span><span class="cov8" title="1">{
                flag.Usage()
                return "", nil, true, true, ExitCodeSuccess
        }</span>

        <span class="cov8" title="1">if flag.NArg() &lt; 1 </span><span class="cov8" title="1">{
                fmt.Println("Error: JSON file path is required")
                flag.Usage()
                return "", nil, true, true, ExitCodeError
        }</span>

        <span class="cov8" title="1">fileName = flag.Arg(0)
        savedTasks, err := in.ReadTasksFromJSON(fileName)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, os.ErrNotExist):<span class="cov0" title="0">
                        fmt.Println("Error: Wrong file path")</span>
                default:<span class="cov8" title="1">
                        fmt.Printf("Error while reading json file: %v\n", err)</span>
                }
                <span class="cov8" title="1">flag.Usage()
                return "", nil, true, true, ExitCodeError</span>
        }
        <span class="cov8" title="1">return fileName, savedTasks, false, false, ExitCodeSuccess</span>
}

func PrintHelp() <span class="cov8" title="1">{
        fmt.Println("Usage: microbrewery-tasks [options] &lt;json-file-path&gt;")
        fmt.Println("\nOptions:")
        flag.PrintDefaults()
        fmt.Println("\nDescription:")
        fmt.Println("  This CLI application reads a JSON file containing microbrewery tasks and displays them.")
        fmt.Println("  Provide the path to the JSON file as an argument.")
}</span>

func displayCommands() <span class="cov8" title="1">{
        fmt.Println("\nAvailable Commands: read, create, update, delete, exit")
        fmt.Print("Enter Command: ")
}</span>

func parseCommand(reader *bufio.Reader) (commands, int, error) <span class="cov8" title="1">{
        cmdString, _ := reader.ReadString('\n')
        parts := strings.Fields(cmdString)
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return "", 0, fmt.Errorf("Please enter a command.")
        }</span>

        <span class="cov8" title="1">cmd := commands(strings.TrimSpace(strings.ToLower(parts[0])))

        var taskId int
        var err error
        if len(parts) &gt; 1 &amp;&amp; (cmd == UPDATE || cmd == DELETE) </span><span class="cov8" title="1">{
                taskId, err = strconv.Atoi(parts[1])
                if err != nil </span><span class="cov8" title="1">{
                        return "", 0, fmt.Errorf("Invalid task ID. Please enter a number.")
                }</span>
        }

        <span class="cov8" title="1">return cmd, taskId, nil</span>
}

func executeCommand(cmd commands, taskId int, taskHolder *in.TaskHolder, reader *bufio.Reader) int <span class="cov8" title="1">{
        var err error
        switch cmd </span>{
        case READ:<span class="cov8" title="1">
                readTasks(taskHolder)</span>
        case CREATE:<span class="cov8" title="1">
                err = createTask(taskHolder, reader)</span>
        case UPDATE:<span class="cov8" title="1">
                err = updateTask(taskHolder, taskId, reader)</span>
        case DELETE:<span class="cov8" title="1">
                err = deleteTask(taskHolder, taskId)</span>
        case EXIT:<span class="cov8" title="1">
                return exitApp(taskHolder)</span>
        default:<span class="cov0" title="0">
                fmt.Println("Invalid command. Please try again.")</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed operation with error: ", err)
        }</span>

        <span class="cov8" title="1">return -1</span> // Continue the loop
}

func exitApp(taskHolder *in.TaskHolder) int <span class="cov8" title="1">{
        fmt.Println("Thank you for using the Task Management CLI. Tasks are saved to ", taskHolder.DiskPath, " GoodBye!")
        err := in.WriteToJson(taskHolder.DiskPath, taskHolder.Tasks...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return 0</span>
}

func deleteTask(taskHolder *in.TaskHolder, taskId int) error <span class="cov8" title="1">{
        err := taskHolder.DeleteTask(taskId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return err</span>
}

func updateTask(taskHolder *in.TaskHolder, taskId int, reader *bufio.Reader) error <span class="cov8" title="1">{
        fmt.Println("Updating task. Press Enter to skip a field if you don't want to update it.")

        // Update task message
        fmt.Print("Enter new task description (or press Enter to skip): ")
        msg, _ := reader.ReadString('\n')
        msg = strings.TrimSpace(msg)

        // Update task status
        var done bool
        var donePtr *bool
        fmt.Print("Update task status? (y/n): ")
        updateStatus, _ := reader.ReadString('\n')
        if strings.ToLower(strings.TrimSpace(updateStatus)) == "y" </span><span class="cov8" title="1">{
                fmt.Print("Is the task done? (true/false): ")
                doneStr, _ := reader.ReadString('\n')
                doneStr = strings.TrimSpace(doneStr)
                if parsedDone, err := strconv.ParseBool(doneStr); err == nil </span><span class="cov8" title="1">{
                        done = parsedDone
                        donePtr = &amp;done
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        // Update task category
        <span class="cov8" title="1">var category in.TaskCategory
        var categoryPtr *in.TaskCategory
        fmt.Print("Update task category? (y/n): ")
        updateCategory, _ := reader.ReadString('\n')
        if strings.ToLower(strings.TrimSpace(updateCategory)) == "y" </span><span class="cov8" title="1">{
                fmt.Println("Available categories:")
                fmt.Println("0: Brewing")
                fmt.Println("1: Marketing")
                fmt.Println("2: Logistics")
                fmt.Println("3: Quality")
                fmt.Print("Enter new category (0-3): ")
                categoryStr, _ := reader.ReadString('\n')
                if parsedCategory, err := strconv.Atoi(strings.TrimSpace(categoryStr)); err == nil &amp;&amp; parsedCategory &gt;= 0 &amp;&amp; parsedCategory &lt;= 3 </span><span class="cov8" title="1">{
                        category = in.TaskCategory(parsedCategory)
                        categoryPtr = &amp;category
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        // Update planned time
        <span class="cov8" title="1">var plannedAt time.Time
        var plannedAtPtr *time.Time
        fmt.Print("Update planned time? (y/n): ")
        updatePlannedTime, _ := reader.ReadString('\n')
        if strings.ToLower(strings.TrimSpace(updatePlannedTime)) == "y" </span><span class="cov8" title="1">{
                fmt.Print("Enter new planned time (YYYY-MM-DD HH:MM): ")
                timeStr, _ := reader.ReadString('\n')
                if parsedTime, err := time.Parse(in.TASK_TIME_FORMAT, strings.TrimSpace(timeStr)); err == nil </span><span class="cov8" title="1">{
                        plannedAt = parsedTime
                        plannedAtPtr = &amp;plannedAt
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        <span class="cov8" title="1">update := in.TaskUpdate{
                Done:      donePtr,
                Msg:       in.StringPtr(msg),
                Category:  categoryPtr,
                PlannedAt: plannedAtPtr,
        }

        err := taskHolder.PartialUpdateTask(taskId, update)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error updating task: %v\n", err)
                return err
        }</span> else<span class="cov8" title="1"> {
                fmt.Println("Task updated successfully.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func createTask(taskHolder *in.TaskHolder, reader *bufio.Reader) error <span class="cov8" title="1">{

        fmt.Println("Enter new task on one line in a format 'task, category, planned to finish date'")
        fmt.Println("Available categories:")
        fmt.Println("0: Brewing")
        fmt.Println("1: Marketing")
        fmt.Println("2: Logistics")
        fmt.Println("3: Quality")
        fmt.Println("Format time (YYYY-MM-DD HH:MM)")
        fmt.Println("Example: `Finish brewing IPA, 0, 2024-08-29 14:27`")

        line, err := reader.ReadString('\n') //TODO unignore errors
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">lines := strings.Split(line, ",")

        taskValue := lines[0]
        categoryNum, err := strconv.Atoi(strings.TrimSpace(lines[1]))
        fmt.Println(categoryNum)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">plannedAt := lines[2]
        var plannedParsedAt time.Time
        parsedTime, err := time.Parse(in.TASK_TIME_FORMAT, strings.TrimSpace(plannedAt))
        if err == nil </span><span class="cov8" title="1">{
                plannedParsedAt = parsedTime
        }</span>
        <span class="cov8" title="1">taskHolder.CreateTask(taskValue, in.TaskCategory(categoryNum), plannedParsedAt)
        return nil</span>
}

func readTasks(taskHolder *in.TaskHolder) <span class="cov8" title="1">{
        all_tasks := taskHolder.Read()
        if len(all_tasks) == 0 </span><span class="cov8" title="1">{
                fmt.Println("No tasks found.")
                return
        }</span>

        <span class="cov8" title="1">fmt.Printf("\nList of tasks:\n\n")
        in.PrintTasks(os.Stdout, all_tasks...)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"
        "net/http"
        "os"
        "time"

        "github.com/zhekagigs/golang_todo/cli"
        "github.com/zhekagigs/golang_todo/frontend"
        "github.com/zhekagigs/golang_todo/internal"
)

type HTTPServer interface {
        ListenAndServe(addr string, handler http.Handler) error
}

type RealHTTPServer struct{}

func (s *RealHTTPServer) ListenAndServe(addr string, handler http.Handler) error <span class="cov0" title="0">{
        return http.ListenAndServe(addr, handler)
}</span>

func main() <span class="cov0" title="0">{
        os.Exit(RealMain(internal.NewTaskHolder, &amp;RealHTTPServer{}, &amp;cli.RealCLIApp{}))
}</span>

func RealMain(newTaskHolder func(diskPath string) *internal.TaskHolder, server HTTPServer, cliApp cli.CLIApp) int <span class="cov8" title="1">{
        taskHolder, checkExit, exitCode := cliApp.AppStarter(newTaskHolder)
        if checkExit </span><span class="cov0" title="0">{
                return exitCode
        }</span>

        <span class="cov8" title="1">go startHTTPServer(taskHolder, server)

        returnCode := cliApp.RunTaskManagmentCLI(taskHolder)
        time.Sleep(100 * time.Millisecond) // waiting for startHttpGoroutine
        return returnCode</span>
}

func startHTTPServer(taskHolder *internal.TaskHolder, server HTTPServer) <span class="cov8" title="1">{
        http.HandleFunc("/tasks", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                frontend.HandleTaskListRead(w, r, taskHolder)
        }</span>)

        <span class="cov8" title="1">http.HandleFunc("/create", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                frontend.HandleTaskListCreate(w, r, taskHolder)
        }</span>)

        <span class="cov8" title="1">log.Println("Starting server on :8080")
        if err := server.ListenAndServe(":8080", nil); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>

}
</pre>
		
		<pre class="file" id="file2" style="display: none">package frontend

import (
        "embed"
        "html/template"
        "io"
        "net/http"
        "strings"
        "time"

        in "github.com/zhekagigs/golang_todo/internal"
)

//go:embed templates/index.html
var templateFiles embed.FS

type TemplateData struct {
        Tasks []in.Task
}

func generateTemplate(indexFile embed.FS) (*template.Template, error) <span class="cov8" title="1">{
        funcMap := template.FuncMap{
                "formatDate": func(t time.Time) string </span><span class="cov8" title="1">{
                        return t.Format("Jan 02, 2006 15:04")
                }</span>,
                "toLowerCase": strings.ToLower,
        }

        <span class="cov8" title="1">tmpl, err := template.New("index.html").Funcs(funcMap).ParseFS(indexFile, "templates/index.html")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return tmpl, nil</span>
}

func HandleTaskListRead(w http.ResponseWriter, r *http.Request, th *in.TaskHolder) <span class="cov8" title="1">{
        tmpl, err := generateTemplate(templateFiles)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">tasks := th.Read()

        data := TemplateData{
                Tasks: tasks,
        }

        err = tmpl.Execute(w, data)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
}

func HandleTaskListCreate(w http.ResponseWriter, r *http.Request, th *in.TaskHolder) <span class="cov0" title="0">{
        tmpl, err := generateTemplate(templateFiles)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">body, _ := io.ReadAll(r.Body)

        task, err := in.UnmarshalTask(body)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">th.Add(*task)

        tasks := th.Read()
        data := TemplateData{
                Tasks: tasks,
        }

        err = tmpl.Execute(w, data)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

}
</pre>
		
		<pre class="file" id="file3" style="display: none">package internal

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"
)

const TASK_TIME_FORMAT = "2006-01-02 15:04"

var jsonMarshal = json.MarshalIndent //for monkey patching mock

// error definitions
var (
        ErrNotFound = errors.New("not found")
)

type InvalidCategoryError struct {
        Category TaskCategory
}

func (e *InvalidCategoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("invalid task category: %v", e.Category)
}</span>

type EmptyTaskValueError struct{}

func (e *EmptyTaskValueError) Error() string <span class="cov0" title="0">{
        return "task value cannot be empty"
}</span>

type PastPlannedTimeError struct {
        PlannedTime time.Time
}

func (e *PastPlannedTimeError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("planned time %v is in the past", e.PlannedTime)
}</span>

type TaskCategory int

const (
        Brewing TaskCategory = iota
        Marketing
        Logistics
        Quality
)

func (tc TaskCategory) String() string <span class="cov8" title="1">{
        return [...]string{"Brewing", "Marketing", "Logistics", "Quality"}[tc]
}</span>

type Task struct {
        Id        int
        Msg       string
        Category  TaskCategory
        Done      bool
        CreatedAt time.Time
        PlannedAt time.Time
}

func NewTask(id int, task string, category TaskCategory, plannedAt time.Time) Task <span class="cov8" title="1">{
        return Task{
                Id:        id,
                Msg:       task,
                Category:  category,
                Done:      false,
                CreatedAt: timeNow().Round(0),
                PlannedAt: plannedAt.Round(0),
        }
}</span>

func (t *Task) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("id:%d,[%s] %s, created: %s, planned: %s, finished: %v",
                t.Id,
                t.Category.String(),
                t.Msg,
                formatDatetime(t.CreatedAt),
                formatDatetime(t.PlannedAt),
                t.Done)
}</span>

func PrintTasks(out io.Writer, tasks ...Task) <span class="cov8" title="1">{
        for _, task := range tasks </span><span class="cov8" title="1">{
                fmt.Fprintln(out, task.String())
        }</span>
}

func WriteToJson(filePath string, tasks ...Task) error <span class="cov8" title="1">{
        if !strings.HasSuffix(filePath, ".json") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid file extension: %s. Expected a .json file", filePath)
        }</span>

        <span class="cov8" title="1">data, err := jsonMarshal(tasks, "", "  ")
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to marshal tasks: %w", err)
        }</span>

        <span class="cov8" title="1">err = os.WriteFile(filePath, data, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to a file '%s': %w", filePath, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ReadTasksFromJSON(filePath string) ([]Task, error) <span class="cov8" title="1">{
        if err := validateJSONFile(filePath); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read file '%s': %w", filePath, err)
        }</span>

        <span class="cov8" title="1">return UnmarshalTasks(data)</span>
}

func UnmarshalTasks(data []byte) ([]Task, error) <span class="cov8" title="1">{
        var tasks []Task
        if err := json.Unmarshal(data, &amp;tasks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>
        <span class="cov8" title="1">return tasks, nil</span>
}

func UnmarshalTask(data []byte) (*Task, error) <span class="cov0" title="0">{
        var task Task
        if err := json.Unmarshal(data, &amp;task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;task, nil</span>
}

func validateJSONFile(filePath string) error <span class="cov8" title="1">{
        ext := filepath.Ext(filePath)
        if ext != ".json" </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid file extension: %s. Expected a .json file", filePath)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package internal

import (
        "fmt"
        "time"
)

type TaskUpdate struct {
        Done      *bool
        Msg       *string
        Category  *TaskCategory
        PlannedAt *time.Time
}

type TaskHolder struct {
        latestId int
        Tasks    []Task
        DiskPath string
}

func NewTaskHolder(diskPath string) *TaskHolder <span class="cov8" title="1">{
        return &amp;TaskHolder{DiskPath: diskPath}
}</span>

func (t *TaskHolder) Read() []Task <span class="cov8" title="1">{
        return t.Tasks
}</span>

func (t *TaskHolder) Add(task Task) <span class="cov8" title="1">{
        t.latestId++
        if task.Id &lt; t.latestId </span><span class="cov0" title="0">{
                task.Id = t.latestId
        }</span>
        <span class="cov8" title="1">t.Tasks = append(t.Tasks, task)</span>

}

func (t *TaskHolder) CreateTask(taskValue string, category TaskCategory, plannedAt time.Time) *Task <span class="cov8" title="1">{
        t.latestId++
        task := NewTask(t.latestId, taskValue, category, plannedAt)
        t.Tasks = append(t.Tasks, task)
        return &amp;task
}</span>

func (t *TaskHolder) FindTaskById(taskId int) (*Task, error) <span class="cov8" title="1">{
        for i := range t.Tasks </span><span class="cov8" title="1">{
                if t.Tasks[i].Id == taskId </span><span class="cov8" title="1">{
                        return &amp;t.Tasks[i], nil
                }</span>
        }
        <span class="cov8" title="1">return nil, ErrNotFound</span>
}

func (t *TaskHolder) PartialUpdateTask(taskId int, update TaskUpdate) error <span class="cov8" title="1">{
        task, err := t.FindTaskById(taskId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if update.Done != nil </span><span class="cov8" title="1">{
                task.Done = *update.Done
        }</span>

        <span class="cov8" title="1">if update.Msg != nil </span><span class="cov8" title="1">{
                if len(*update.Msg) == 0 </span><span class="cov8" title="1">{
                        return &amp;EmptyTaskValueError{}
                }</span>
                <span class="cov8" title="1">task.Msg = *update.Msg</span>
        }

        <span class="cov8" title="1">if update.Category != nil </span><span class="cov8" title="1">{
                if !isValidTaskCategory(*update.Category) </span><span class="cov8" title="1">{
                        return &amp;InvalidCategoryError{Category: *update.Category}
                }</span>
                <span class="cov8" title="1">task.Category = *update.Category</span>
        }

        <span class="cov8" title="1">if update.PlannedAt != nil </span><span class="cov8" title="1">{
                if update.PlannedAt.Before(time.Now()) </span><span class="cov8" title="1">{
                        return &amp;PastPlannedTimeError{PlannedTime: *update.PlannedAt}
                }</span>
                <span class="cov8" title="1">task.PlannedAt = *update.PlannedAt</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (t *TaskHolder) DeleteTask(taskId int) error <span class="cov8" title="1">{
        index := -1
        for i, task := range t.Tasks </span><span class="cov8" title="1">{
                if task.Id == taskId </span><span class="cov8" title="1">{
                        index = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if index == -1 </span><span class="cov8" title="1">{
                return fmt.Errorf("task with ID %d not found", taskId)
        }</span>

        <span class="cov8" title="1">t.Tasks = append(t.Tasks[:index], t.Tasks[index+1:]...)

        return nil</span>
}

func isValidTaskCategory(category TaskCategory) bool <span class="cov8" title="1">{
        return Brewing &lt;= category &amp;&amp; category &lt;= Quality
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package internal

import (
        "bytes"
        "io"
        "os"
        "testing"
        "time"
)

var MockTime = time.Date(2023, 7, 23, 12, 0, 0, 0, time.UTC)

func ProvideMocktimeNow(t *testing.T) func() time.Time <span class="cov8" title="1">{
        originalTimeNow := timeNow
        t.Cleanup(func() </span><span class="cov8" title="1">{
                timeNow = originalTimeNow
        }</span>)
        <span class="cov8" title="1">return func() time.Time </span><span class="cov8" title="1">{
                return MockTime
        }</span>
}

func ProvideTask(t *testing.T) Task <span class="cov8" title="1">{
        return NewTask(1, "task_my_task", 1, MockTime)
}</span>

func ProvideTaskHolder() *TaskHolder <span class="cov0" title="0">{
        th := NewTaskHolder("../resources/cli_disk_test.json")
        th.CreateTask("Initial Task", Brewing, time.Now().Add(24*time.Hour))
        return th
}</span>

func MockNewTaskHolder(diskPath string) *TaskHolder <span class="cov0" title="0">{

        th := NewTaskHolder("../resources/cli_disk_test.json")
        th.CreateTask("Initial Task", Brewing, time.Now().Add(24*time.Hour))
        return th
}</span>

func ReadCapturedStdout(r *os.File) string <span class="cov0" title="0">{
        var buf bytes.Buffer
        io.Copy(&amp;buf, r)
        output := buf.String()
        return output
}</span>

func WriteToCapturedStdin(write *os.File, cmnds []string) <span class="cov0" title="0">{
        time.Sleep(100 * time.Millisecond)
        for _, cmnd := range cmnds </span><span class="cov0" title="0">{
                write.Write([]byte(cmnd))
                time.Sleep(100 * time.Millisecond)
        }</span>
}

// Restore after capturing
func RestoreStdout(w *os.File, oldStdout *os.File) <span class="cov0" title="0">{
        w.Close()
        os.Stdout = oldStdout
}</span>

// Restore after capturing
func RestoreStdin(r *os.File, oldStdin *os.File) <span class="cov0" title="0">{
        r.Close()
        os.Stdin = oldStdin
}</span>

// Capture stdout. DON'T FORGET TO RESTORE!
func CaptureStdout() (oldStdout *os.File, read *os.File, write *os.File) <span class="cov0" title="0">{
        oldStdout = os.Stdout
        read, write, _ = os.Pipe()
        os.Stdout = write
        return
}</span>

// Capture stdin. DON'T FORGET TO RESTORE!
func CaptureStdin() (oldStdin *os.File, read *os.File, write *os.File) <span class="cov0" title="0">{
        oldStdin = os.Stdin
        read, write, _ = os.Pipe()
        os.Stdin = read
        return
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package internal

import (
        "fmt"
        "math/rand"
        "os"
        "strings"
        "time"
)

var timeNow = time.Now

func check(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
}

func formatDatetime(t time.Time) string <span class="cov8" title="1">{
        return t.Format("Monday, January 2, 2006 at 15:04")
}</span>

func generateRandomTasks(count int) []Task <span class="cov8" title="1">{
        brewingVerbs := []string{"Brew", "Ferment", "Bottle", "Label", "Clean", "Inspect", "Order", "Taste"}
        adjectives := []string{"Hoppy", "Malty", "Crisp", "Smooth", "Tangy", "Barrel-aged", "Experimental", "Funky", "Juicy", "Hazy", "Robust", "Refreshing"}
        beerTypes := []string{"IPA", "Stout", "Lager", "Wheat Beer", "Pale Ale", "Porter", "Sour", "Seasonal Batch"}
        ingredients := []string{"Hops", "Malt", "Yeast", "Fruit puree", "Spices", "Coffee beans", "Cocoa nibs", "Oak chips"}
        marketingTasks := []string{"Design new label", "Plan social media campaign", "Organize tasting event", "Create promotional video", "Update website", "Develop brand partnership", "Analyze market trends", "Conduct customer survey"}
        logisticsTasks := []string{"Schedule delivery route", "Inventory check", "Restock supplies", "Maintain delivery vehicles", "Optimize warehouse layout", "Negotiate with suppliers", "Update inventory management system", "Coordinate with distributors"}
        qualityTasks := []string{"Conduct sensory analysis", "Calibrate testing equipment", "Review quality control procedures", "Train staff on quality standards", "Perform microbiological testing", "Update quality assurance documentation", "Conduct supplier quality audit", "Implement new quality control measure"}

        tasks := make([]Task, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                var taskValue string
                var category TaskCategory
                x := rand.Intn(5)
                switch x </span>{
                case 0:<span class="cov8" title="1">
                        verb := brewingVerbs[rand.Intn(len(brewingVerbs))]
                        adj := adjectives[rand.Intn(len(adjectives))]
                        noun := beerTypes[rand.Intn(len(beerTypes))]
                        taskValue = strings.Join([]string{verb, adj, noun}, " ")
                        category = Brewing</span>
                case 1:<span class="cov8" title="1">
                        verb := "Process"
                        if rand.Intn(2) == 0 </span><span class="cov0" title="0">{
                                verb = "Order"
                        }</span>
                        <span class="cov8" title="1">ingredient := ingredients[rand.Intn(len(ingredients))]
                        quantity := rand.Intn(500) + 1 // 1 to 500
                        unit := "kg"
                        if rand.Intn(2) == 0 </span><span class="cov0" title="0">{
                                unit = "lbs"
                        }</span>
                        <span class="cov8" title="1">taskValue = fmt.Sprintf("%s %d %s of %s", verb, quantity, unit, ingredient)
                        category = Brewing</span>
                case 2:<span class="cov8" title="1">
                        taskValue = marketingTasks[rand.Intn(len(marketingTasks))]
                        category = Marketing</span>
                case 3:<span class="cov8" title="1">
                        taskValue = logisticsTasks[rand.Intn(len(logisticsTasks))]
                        category = Logistics</span>
                case 4:<span class="cov8" title="1">
                        taskValue = qualityTasks[rand.Intn(len(qualityTasks))]
                        category = Quality</span>

                }
                <span class="cov8" title="1">plannedAt := time.Now().Add(time.Duration(rand.Intn(24*30)) * time.Hour)
                newTask := NewTask(i, taskValue, category, plannedAt)
                tasks[i] = newTask</span>
        }
        <span class="cov8" title="1">return tasks</span>
}

func BeerAscii() string <span class="cov8" title="1">{
        data, err := os.ReadFile("../resources/beer.txt")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("error happened while reading beer logo: ", err)
                return ""
        }</span>
        <span class="cov8" title="1">return string(data)</span>
}

func StringPtr(s string) *string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;s</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
