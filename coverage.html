
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/zhekagigs/golang_todo/cli/cli.go (91.1%)</option>
				
				<option value="file1">github.com/zhekagigs/golang_todo/cmd/main.go (52.5%)</option>
				
				<option value="file2">github.com/zhekagigs/golang_todo/handlers/api.go (16.7%)</option>
				
				<option value="file3">github.com/zhekagigs/golang_todo/handlers/serv.go (0.0%)</option>
				
				<option value="file4">github.com/zhekagigs/golang_todo/handlers/task_handler.go (65.7%)</option>
				
				<option value="file5">github.com/zhekagigs/golang_todo/internal/task.go (74.3%)</option>
				
				<option value="file6">github.com/zhekagigs/golang_todo/internal/taskHolder.go (73.8%)</option>
				
				<option value="file7">github.com/zhekagigs/golang_todo/internal/taskService.go (0.0%)</option>
				
				<option value="file8">github.com/zhekagigs/golang_todo/internal/testutils.go (89.5%)</option>
				
				<option value="file9">github.com/zhekagigs/golang_todo/internal/utils.go (78.8%)</option>
				
				<option value="file10">github.com/zhekagigs/golang_todo/logger/logger.go (100.0%)</option>
				
				<option value="file11">github.com/zhekagigs/golang_todo/view/view.go (94.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cli

import (
        "bufio"
        "errors"
        "flag"
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        in "github.com/zhekagigs/golang_todo/internal"
)

type commands string

const (
        READ   commands = "read"
        CREATE commands = "create"
        UPDATE commands = "update"
        DELETE commands = "delete"
        EXIT   commands = "exit"
)

const (
        ExitCodeSuccess = 0
        ExitCodeError   = 1
)

type CLIApp interface {
        AppStarter(newTaskHolder func(diskPath string) *in.TaskHolder) (*in.TaskHolder, bool, int)
        RunTaskManagmentCLI(taskHolder *in.TaskHolder) int
}

type RealCLIApp struct {
}

func (cli *RealCLIApp) RunTaskManagmentCLI(taskHolder *in.TaskHolder) int <span class="cov8" title="1">{
        reader := bufio.NewReader(os.Stdin)
        for </span><span class="cov8" title="1">{
                displayCommands()
                cmd, taskId, err := parseCommand(reader)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        continue</span>
                }

                <span class="cov8" title="1">if exitCode := executeCommand(cmd, taskId, taskHolder, reader); exitCode != -1 </span><span class="cov8" title="1">{
                        return exitCode
                }</span>
        }
}

func (cli *RealCLIApp) AppStarter(newTaskHolder func(diskPath string) *in.TaskHolder) (*in.TaskHolder, bool, int) <span class="cov8" title="1">{
        fileName, savedTasks, isHelp, isExit, exitCode := ParseUserArg()
        if isHelp </span><span class="cov8" title="1">{
                return nil, isExit, exitCode
        }</span>
        <span class="cov8" title="1">PrintCLITitle(savedTasks)

        taskHolder, err := PopulateTaskHolder(fileName, savedTasks, newTaskHolder)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error populating task holder: %v\n", err)
                return nil, true, ExitCodeError
        }</span>
        <span class="cov8" title="1">return taskHolder, false, ExitCodeSuccess</span>
}

func PrintCLITitle(savedTasks []in.Task) <span class="cov8" title="1">{
        fmt.Println(in.BeerAscii())
        fmt.Printf("\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Microbrewery Tasks Application&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n\n")
        in.PrintTasks(os.Stdout, savedTasks...)
}</span>

func PopulateTaskHolder(fileName string, savedTasks []in.Task, newTaskHolder func(diskPath string) *in.TaskHolder) (*in.TaskHolder, error) <span class="cov8" title="1">{
        if fileName == "" </span><span class="cov0" title="0">{
                fileName = "resources/disk.json"
        }</span>
        <span class="cov8" title="1">taskHolder := newTaskHolder(fileName)
        // var maxId int TODO ?
        for _, task := range savedTasks </span><span class="cov8" title="1">{
                // if task.Id &gt; maxId {
                //         maxId = task.Id
                // }
                taskHolder.Add(task)
        }</span>
        <span class="cov8" title="1">return taskHolder, nil</span>
}

func ParseUserArg() (fileName string, savedTasks []in.Task, isHelp bool, isExit bool, exitCode int) <span class="cov8" title="1">{
        helpFlag := flag.Bool("h", false, "Help is here")

        flag.Usage = PrintHelp

        flag.Parse()

        if *helpFlag </span><span class="cov8" title="1">{
                flag.Usage()
                return "", nil, true, true, ExitCodeSuccess
        }</span>

        <span class="cov8" title="1">if flag.NArg() &lt; 1 </span><span class="cov8" title="1">{
                fmt.Println("Error: JSON file path is required")
                flag.Usage()
                return "", nil, true, true, ExitCodeError
        }</span>

        <span class="cov8" title="1">fileName = flag.Arg(0)
        savedTasks, err := in.ReadTasksFromJSON(fileName)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, os.ErrNotExist):<span class="cov0" title="0">
                        fmt.Println("Error: Wrong file path")</span>
                default:<span class="cov8" title="1">
                        fmt.Printf("Error while reading json file: %v\n", err)</span>
                }
                <span class="cov8" title="1">flag.Usage()
                return "", nil, true, true, ExitCodeError</span>
        }
        <span class="cov8" title="1">return fileName, savedTasks, false, false, ExitCodeSuccess</span>
}

func PrintHelp() <span class="cov8" title="1">{
        fmt.Println("Usage: microbrewery-tasks [options] &lt;json-file-path&gt;")
        fmt.Println("\nOptions:")
        flag.PrintDefaults()
        fmt.Println("\nDescription:")
        fmt.Println("  This CLI application reads a JSON file containing microbrewery tasks and displays them.")
        fmt.Println("  Provide the path to the JSON file as an argument.")
}</span>

func displayCommands() <span class="cov8" title="1">{
        fmt.Println("\nAvailable Commands: read, create, update, delete, exit")
        fmt.Print("Enter Command: ")
}</span>

func parseCommand(reader *bufio.Reader) (commands, int, error) <span class="cov8" title="1">{
        cmdString, _ := reader.ReadString('\n')
        parts := strings.Fields(cmdString)
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return "", 0, fmt.Errorf("Please enter a command.")
        }</span>

        <span class="cov8" title="1">cmd := commands(strings.TrimSpace(strings.ToLower(parts[0])))

        var taskId int
        var err error
        if len(parts) &gt; 1 &amp;&amp; (cmd == UPDATE || cmd == DELETE) </span><span class="cov8" title="1">{
                taskId, err = strconv.Atoi(parts[1])
                if err != nil </span><span class="cov8" title="1">{
                        return "", 0, fmt.Errorf("Invalid task ID. Please enter a number.")
                }</span>
        }

        <span class="cov8" title="1">return cmd, taskId, nil</span>
}

func executeCommand(cmd commands, taskId int, taskHolder *in.TaskHolder, reader *bufio.Reader) int <span class="cov8" title="1">{
        var err error
        switch cmd </span>{
        case READ:<span class="cov8" title="1">
                readTasks(taskHolder)</span>
        case CREATE:<span class="cov8" title="1">
                err = createTask(taskHolder, reader)</span>
        case UPDATE:<span class="cov8" title="1">
                err = updateTask(taskHolder, taskId, reader)</span>
        case DELETE:<span class="cov8" title="1">
                err = deleteTask(taskHolder, taskId)</span>
        case EXIT:<span class="cov8" title="1">
                return exitApp(taskHolder)</span>
        default:<span class="cov0" title="0">
                fmt.Println("Invalid command. Please try again.")</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                fmt.Println("Failed operation with error: ", err)
        }</span>

        <span class="cov8" title="1">return -1</span> // Continue the loop
}

func exitApp(taskHolder *in.TaskHolder) int <span class="cov8" title="1">{
        fmt.Println("Thank you for using the Task Management CLI. Tasks are saved to ", taskHolder.DiskPath, " GoodBye!")
        err := in.WriteToJson(taskHolder.DiskPath, taskHolder.Tasks...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return 0</span>
}

func deleteTask(taskHolder *in.TaskHolder, taskId int) error <span class="cov8" title="1">{
        err := taskHolder.DeleteTask(taskId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return err</span>
}

func updateTask(taskHolder *in.TaskHolder, taskId int, reader *bufio.Reader) error <span class="cov8" title="1">{
        fmt.Println("Updating task. Press Enter to skip a field if you don't want to update it.")

        // Update task message
        fmt.Print("Enter new task description (or press Enter to skip): ")
        msg, _ := reader.ReadString('\n')
        msg = strings.TrimSpace(msg)

        // Update task status
        var donePtr *bool
        fmt.Print("Update task status? (y/n): ")
        updateStatus, _ := reader.ReadString('\n')
        if strings.ToLower(strings.TrimSpace(updateStatus)) == "y" </span><span class="cov8" title="1">{
                fmt.Print("Is the task done? (true/false): ")
                doneStr, _ := reader.ReadString('\n')
                doneStr = strings.TrimSpace(doneStr)
                if parsedDone, err := strconv.ParseBool(doneStr); err == nil </span><span class="cov8" title="1">{
                        donePtr = &amp;parsedDone
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        // Update task category
        <span class="cov8" title="1">var category in.TaskCategory
        var categoryPtr *in.TaskCategory
        fmt.Print("Update task category? (y/n): ")
        updateCategory, _ := reader.ReadString('\n')
        if strings.ToLower(strings.TrimSpace(updateCategory)) == "y" </span><span class="cov8" title="1">{
                fmt.Println("Available categories:")
                fmt.Println("0: Brewing")
                fmt.Println("1: Marketing")
                fmt.Println("2: Logistics")
                fmt.Println("3: Quality")
                fmt.Print("Enter new category (0-3): ")
                categoryStr, _ := reader.ReadString('\n')
                if parsedCategory, err := strconv.Atoi(strings.TrimSpace(categoryStr)); err == nil &amp;&amp; parsedCategory &gt;= 0 &amp;&amp; parsedCategory &lt;= 3 </span><span class="cov8" title="1">{
                        category = in.TaskCategory(parsedCategory)
                        categoryPtr = &amp;category
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        // Update planned time
        <span class="cov8" title="1">var plannedAtPtr *time.Time
        fmt.Print("Update planned time? (y/n): ")
        updatePlannedTime, _ := reader.ReadString('\n')
        if strings.ToLower(strings.TrimSpace(updatePlannedTime)) == "y" </span><span class="cov8" title="1">{
                fmt.Print("Enter new planned time (YYYY-MM-DD HH:MM): ")
                timeStr, _ := reader.ReadString('\n')
                fmt.Println("timeStr", timeStr)
                if parsedTime, err := time.Parse(in.TASK_TIME_FORMAT, strings.TrimSpace(timeStr)); err == nil </span><span class="cov8" title="1">{
                        plannedAtPtr = &amp;parsedTime
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }
        <span class="cov8" title="1">customTime, err := in.NewCustomTime(plannedAtPtr)
        if err != nil </span><span class="cov8" title="1">{
                if err != in.ErrTimeNilPointer </span><span class="cov0" title="0">{
                        fmt.Printf("Error updating task: %v\n", err)
                        return err
                }</span>
        }

        <span class="cov8" title="1">update := &amp;in.TaskOptional{
                Done:      donePtr,
                Msg:       in.StringPtr(msg),
                Category:  categoryPtr,
                PlannedAt: customTime,
        }

        err = taskHolder.PartialUpdateTask(taskId, update)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Error updating task: %v\n", err)
                return err
        }</span> else<span class="cov8" title="1"> {
                fmt.Println("Task updated successfully.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func createTask(taskHolder *in.TaskHolder, reader *bufio.Reader) error <span class="cov8" title="1">{

        fmt.Println("Enter new task on one line in a format 'task, category, planned to finish date'")
        fmt.Println("Available categories:")
        fmt.Println("0: Brewing")
        fmt.Println("1: Marketing")
        fmt.Println("2: Logistics")
        fmt.Println("3: Quality")
        fmt.Println("Format time (YYYY-MM-DD HH:MM)")
        fmt.Println("Example: `Finish brewing IPA, 0, 2024-08-29 14:27`")

        line, err := reader.ReadString('\n') //TODO unignore errors
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">lines := strings.Split(line, ",")

        taskValue := lines[0]
        categoryNum, err := strconv.Atoi(strings.TrimSpace(lines[1]))
        fmt.Println(categoryNum)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">plannedAt := lines[2]
        var plannedParsedAt time.Time
        parsedTime, err := time.Parse(in.TASK_TIME_FORMAT, strings.TrimSpace(plannedAt))
        if err == nil </span><span class="cov8" title="1">{
                plannedParsedAt = parsedTime
        }</span>
        <span class="cov8" title="1">updt := in.TaskOptional{
                Done:      nil,
                Msg:       in.StringPtr(taskValue),
                Category:  in.CategoryPtr(in.TaskCategory(categoryNum)),
                PlannedAt: in.TimePtr(plannedParsedAt),
        }

        taskHolder.CreateTask(updt)
        return nil</span>
}

func readTasks(taskHolder *in.TaskHolder) <span class="cov8" title="1">{
        all_tasks := taskHolder.Read()
        if len(all_tasks) == 0 </span><span class="cov8" title="1">{
                fmt.Println("No tasks found.")
                return
        }</span>

        <span class="cov8" title="1">fmt.Printf("\nList of tasks:\n\n")
        in.PrintTasks(os.Stdout, all_tasks...)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"
        "net/http"
        "os"
        "time"

        "github.com/zhekagigs/golang_todo/cli"
        "github.com/zhekagigs/golang_todo/handlers"
        "github.com/zhekagigs/golang_todo/internal"
        "github.com/zhekagigs/golang_todo/logger"
        "github.com/zhekagigs/golang_todo/view"
)

func main() <span class="cov0" title="0">{
        os.Exit(RealMain(internal.NewTaskHolder, &amp;handlers.RealHTTPServer{}, &amp;cli.RealCLIApp{}))
}</span>

func RealMain(newTaskHolder func(diskPath string) *internal.TaskHolder, server handlers.HTTPServer, cliApp cli.CLIApp) int <span class="cov8" title="1">{
        taskHolder, checkExit, exitCode := cliApp.AppStarter(newTaskHolder)
        if checkExit </span><span class="cov0" title="0">{
                return exitCode
        }</span>

        <span class="cov8" title="1">renderer, err := view.NewRenderer()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error.Printf("error starting view renderer")
        }</span>
        <span class="cov8" title="1">taskConcurrentService := internal.NewConcurrentTaskService(taskHolder)
        taskRenderHandler := handlers.NewTaskRenderHandler(taskHolder, renderer)

        api := handlers.NewApiService(taskConcurrentService)

        go startHTTPServer(taskRenderHandler, server, api)

        returnCode := cliApp.RunTaskManagmentCLI(taskHolder)
        time.Sleep(100 * time.Millisecond) // waiting for startHttpGoroutine
        return returnCode</span>
}

func startHTTPServer(taskHandler *handlers.TaskRenderHandler, server handlers.HTTPServer, api *handlers.ApiService) <span class="cov8" title="1">{

        router := http.NewServeMux()
        router.Handle("/api/", api) //why?
        router.HandleFunc("GET /api/tasks", api.GetAllPosts)
        router.HandleFunc("GET /api/tasks/{id}", api.GetTaskById)
        router.HandleFunc("POST /api/tasks", api.CreateTask)

        http.HandleFunc("/tasks", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                logger.Info.Printf("Method: %s, URL: %s", r.Method, r.URL.Path)
                switch r.Method </span>{
                case http.MethodGet:<span class="cov0" title="0">
                        taskHandler.HandleTaskListRead(w, r)</span>
                case http.MethodDelete:<span class="cov0" title="0">
                        taskHandler.HandleTaskDelete(w, r)</span>
                default:<span class="cov0" title="0">
                        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
                }
        })

        <span class="cov8" title="1">http.HandleFunc("/tasks/update", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                logger.Info.Printf("Method: %s, URL: %s", r.Method, r.URL.Path)
                taskHandler.HandleTaskUpdate(w, r)
        }</span>)

        <span class="cov8" title="1">http.HandleFunc("/tasks/create", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                logger.Info.Printf("Method: %s, URL: %s", r.Method, r.URL.Path)
                taskHandler.HandleTaskCreate(w, r)
        }</span>)

        <span class="cov8" title="1">log.Println("Starting server on :8080")
        if err := server.ListenAndServe(":8080", router); err != nil </span><span class="cov0" title="0">{
                logger.Error.Fatalf("Failed to start server: %v", err)
        }</span>
}

func logMiddleware(next http.HandlerFunc) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                // Create a custom response writer to capture the status code
                crw := &amp;customResponseWriter{ResponseWriter: w}

                next.ServeHTTP(crw, r)

                duration := time.Since(start)

                log.Printf(
                        "Method: %s, Path: %s, Status: %d, Duration: %v",
                        r.Method,
                        r.URL.Path,
                        crw.status,
                        duration,
                )
        }</span>
}

type customResponseWriter struct {
        http.ResponseWriter
        status int
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"

        "github.com/zhekagigs/golang_todo/internal"
        "github.com/zhekagigs/golang_todo/logger"
)

var (
        ErrWrongRequest = errors.New("wrong request")
        ErrInternal     = errors.New("server error")
)

type ApiService struct {
        // taskService  *internal.TaskHolder
        taskService *internal.ConcurrentTaskService
}

func (apiHandler ApiService) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logger.Info.Printf("ServeHttp Received %s request for %s from %s", r.Method, r.URL.Path, r.RemoteAddr)
}</span>

func NewApiService(internal *internal.ConcurrentTaskService) *ApiService <span class="cov8" title="1">{
        return &amp;ApiService{
                taskService: internal,
        }
}</span>

func (api *ApiService) GetAllPosts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        posts := api.taskService.Read()

        postsJson, err := json.Marshal(posts)
        if isJsonErr(err, w) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write(postsJson)</span>
}

func (api *ApiService) GetTaskById(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        taskId, err := getTaskIdFromPath(r)
        if handleError(w, err, http.StatusInternalServerError, "api: error processing taskId") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">task, err := api.taskService.FindTaskById(taskId)
        if handleError(w, err, http.StatusInternalServerError, "api: task not found") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">taskJson, err := json.Marshal(task)
        if isJsonErr(err, w) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader((http.StatusOK))
        w.Write(taskJson)</span>
}

func (api *ApiService) CreateTask(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var taskRequest *internal.TaskOptional
        err := json.NewDecoder(r.Body).Decode(&amp;taskRequest)
        if handleError(w, err, http.StatusBadRequest, "error decoding request body") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">task := api.taskService.CreateTask(*taskRequest)
        taskAsJson, err := json.Marshal(task)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrInternal.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-type", "application/json")
        w.WriteHeader(http.StatusCreated)
        w.Write(taskAsJson)</span>
}

func (api *ApiService) UpdateTask(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var taskRequest *internal.TaskOptional
        err := json.NewDecoder(r.Body).Decode(&amp;taskRequest)
        if handleError(w, err, http.StatusBadRequest, "error decoding request body") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">taskId, err := getTaskIdFromPath(r)
        if handleError(w, err, http.StatusBadRequest, "error parsing taskId") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">task := api.taskService.PartialUpdateTask(taskId, taskRequest)
        taskAsJson, err := json.Marshal(task)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrInternal.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-type", "application/json")
        w.WriteHeader(http.StatusCreated)
        w.Write(taskAsJson)</span>
}

func (api *ApiService) DeleteTask(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        taskId, err := getTaskIdFromPath(r)
        if handleError(w, err, http.StatusBadRequest, "api: error processing taskId") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">err = api.taskService.DeleteTask(taskId)
        if handleError(w, err, http.StatusBadRequest, "api: task not foound") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">w.WriteHeader((http.StatusOK))</span>
}

func isJsonErr(err error, w http.ResponseWriter) bool <span class="cov0" title="0">{
        return handleError(w, err, http.StatusBadRequest, "api: json serialization error")
}</span>

func getTaskIdFromPath(r *http.Request) (int, error) <span class="cov0" title="0">{
        taskIdStr := r.PathValue("id")
        if taskIdStr == "" </span><span class="cov0" title="0">{
                return -1, errors.New("task id is empty")
        }</span>
        <span class="cov0" title="0">return strconv.Atoi(taskIdStr)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "context"
        "net/http"
)

type HTTPServer interface {
        ListenAndServe(addr string, handler http.Handler) error
        Shutdown(ctx context.Context) error
}

type RealHTTPServer struct {
        server *http.Server
}

func (s *RealHTTPServer) ListenAndServe(addr string, handler http.Handler) error <span class="cov0" title="0">{

        return http.ListenAndServe(addr, handler)
}</span>

func (s *RealHTTPServer) Shutdown(ctx context.Context) error <span class="cov0" title="0">{

        return s.server.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/zhekagigs/golang_todo/internal"
        "github.com/zhekagigs/golang_todo/logger"
        "github.com/zhekagigs/golang_todo/view"
)

type TaskRenderHandler struct {
        service  internal.TaskServiceInterface
        renderer view.Renderer
}

func handleError(w http.ResponseWriter, err error, status int, message string) bool <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                if err == internal.ErrNotFound </span><span class="cov0" title="0">{
                        logger.Error.Printf("Task not found: %s", message)
                        http.Error(w, "Task not found", http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> {
                        logger.Error.Printf("%s: %v", message, err)
                        if message == "" </span><span class="cov0" title="0">{
                                message = err.Error()
                        }</span>
                        <span class="cov0" title="0">http.Error(w, message, status)</span>
                }

                <span class="cov0" title="0">return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func getTaskIdFromQuery(r *http.Request) (int, error) <span class="cov8" title="1">{
        taskIDStr := r.URL.Query().Get("id")
        if taskIDStr == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("missing Task ID")
        }</span>
        <span class="cov8" title="1">return strconv.Atoi(taskIDStr)</span>
}

func NewTaskRenderHandler(service internal.TaskServiceInterface, renderer view.Renderer) *TaskRenderHandler <span class="cov8" title="1">{
        return &amp;TaskRenderHandler{service: service, renderer: renderer}
}</span>

func (h *TaskRenderHandler) HandleTaskListRead(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">tasks := h.service.Read()

        err := h.renderer.RenderTaskList(w, tasks)
        if handleError(w, err, http.StatusInternalServerError, "") </span><span class="cov0" title="0">{
                return
        }</span>
}

func (h *TaskRenderHandler) HandleTaskCreate(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // logger.Info.Printf("Handling %s request for task creation from %s", r.Method, r.RemoteAddr)
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                err := h.renderer.RenderCreateForm(w)
                handleError(w, err, http.StatusInternalServerError, "")
                return</span>
        case http.MethodPost:<span class="cov8" title="1">
                taskOptional, err := ExtractFormValues(r)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error.Printf("Error extracting form values: %v", err)
                        http.Error(w, "Invalid form data", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">task := h.service.CreateTask(*taskOptional)

                if task == nil </span><span class="cov0" title="0">{
                        logger.Error.Println("Failed to create task")
                        http.Error(w, "Failed to create task", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">logger.Info.Printf("Successfully created task with ID: %d", task.Id)
                http.Redirect(w, r, "/tasks", http.StatusSeeOther)
                return</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Invalid method", http.StatusBadRequest)</span>
        }
}

func (h *TaskRenderHandler) HandleTaskUpdate(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        logger.Info.Printf("Handling %s request for task update from %s", r.Method, r.RemoteAddr)

        taskID, err := getTaskIdFromQuery(r)
        if handleError(w, err, http.StatusBadRequest, "Invalid task ID") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                h.handleGetTaskUpdate(w, taskID)</span>
        case http.MethodPost:<span class="cov8" title="1">
                h.handlePostTaskUpdate(w, r, taskID)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

func (h *TaskRenderHandler) handleGetTaskUpdate(w http.ResponseWriter, taskID int) <span class="cov8" title="1">{
        task, err := h.service.FindTaskById(taskID)
        if handleError(w, err, http.StatusNotFound, "Task not found") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">err = h.renderer.RenderTaskUpdate(w, task)
        handleError(w, err, http.StatusInternalServerError, "Error rendering update form")</span>
}

func (h *TaskRenderHandler) handlePostTaskUpdate(w http.ResponseWriter, r *http.Request, taskID int) <span class="cov8" title="1">{
        update, err := ExtractFormValues(r)
        if handleError(w, err, http.StatusBadRequest, "Invalid form data") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">logger.Info.Printf("Updating task with ID: %d", taskID)
        err = h.service.PartialUpdateTask(taskID, update)
        if handleError(w, err, http.StatusInternalServerError, "Failed to update task") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">logger.Info.Printf("Successfully updated task with ID: %d", taskID)
        http.Redirect(w, r, "/tasks", http.StatusSeeOther)</span>
}

func (h *TaskRenderHandler) HandleTaskDelete(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // logger.Info.Printf("Handling %s request for task deletion from %s", r.Method, r.RemoteAddr)
        if r.Method != http.MethodDelete </span><span class="cov0" title="0">{
                logger.Error.Printf("Method not allowed: %s", r.Method)
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov8" title="1">taskID, err := getTaskIdFromQuery(r)
        err = h.service.DeleteTask(taskID)
        if handleError(w, err, http.StatusInternalServerError, fmt.Sprint(taskID)) </span><span class="cov0" title="0">{
                return
        }</span>

        // logger.Info.Printf("Successfully deleted task with ID: %d", taskID)
        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}

func ExtractFormValues(r *http.Request) (*internal.TaskOptional, error) <span class="cov8" title="1">{
        // logger.Info.Println("Extracting form values")

        var errs []error
        addErr := func(err error, msg string) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("%s: %w", msg, err))
                        logger.Error.Printf("%s: %v", msg, err)
                }</span>
        }
        <span class="cov8" title="1">checkErr := func(err error, msg string) </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        addErr(err, msg)
                }</span>
        }
        <span class="cov8" title="1">msg := r.FormValue("msg")

        category, err := strconv.Atoi(r.FormValue("category"))
        checkErr(err, "Invalid category")

        dateString := r.FormValue("plannedAt")
        var plannedAt *internal.CustomTime
        if dateString != "" </span><span class="cov8" title="1">{
                plannedData, err := time.Parse("2006-01-02T15:04", dateString)
                plannedAt = internal.TimePtr(plannedData)
                checkErr(err, "invalid planned time")
        }</span> else<span class="cov0" title="0"> {
                plannedAt = nil
        }</span>

        <span class="cov8" title="1">var done *bool
        doneValue := r.FormValue("done")
        if doneValue != "" </span><span class="cov8" title="1">{
                doneBool, err := strconv.ParseBool(doneValue)
                done = internal.BoolPtr(doneBool)
                checkErr(err, "invalid done value")
        }</span> else<span class="cov8" title="1"> {
                done = nil
        }</span>

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                logger.Error.Printf("Form value errors: %v", errs)
                return nil, fmt.Errorf("form value errors: %v", errs)
        }</span>
        <span class="cov8" title="1">update := &amp;internal.TaskOptional{
                Done:      done,
                Msg:       internal.StringPtr(msg),
                Category:  (*internal.TaskCategory)(&amp;category),
                PlannedAt: plannedAt,
        }
        logger.Info.Printf("Successfully extracted form values: %+v", update)
        return update, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package internal

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"
)

const TASK_TIME_FORMAT = "2006-01-02 15:04"

var jsonMarshal = json.MarshalIndent //for monkey patching mock

// error definitions
var (
        ErrNotFound = errors.New("not found")
)

type InvalidCategoryError struct {
        Category TaskCategory
}

func (e *InvalidCategoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("invalid task category: %v", e.Category)
}</span>

type EmptyTaskValueError struct{}

func (e *EmptyTaskValueError) Error() string <span class="cov0" title="0">{
        return "task value cannot be empty"
}</span>

type PastPlannedTimeError struct {
        PlannedTime time.Time
}

func (e *PastPlannedTimeError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("planned time %v is in the past", e.PlannedTime)
}</span>

type TaskCategory int

const (
        Brewing TaskCategory = iota
        Marketing
        Logistics
        Quality
)

func (tc TaskCategory) String() string <span class="cov8" title="1">{
        return [...]string{"Brewing", "Marketing", "Logistics", "Quality"}[tc]
}</span>

type Task struct {
        Id        int
        Msg       string
        Category  TaskCategory
        Done      bool
        CreatedAt time.Time
        PlannedAt time.Time
}

func NewTask(id int, task string, category TaskCategory, plannedAt time.Time) Task <span class="cov8" title="1">{
        return Task{
                Id:        id,
                Msg:       task,
                Category:  category,
                Done:      false,
                CreatedAt: timeNow().Round(0),
                PlannedAt: plannedAt.Round(0),
        }
}</span>

func (t *Task) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("id:%d,[%s] %s, created: %s, planned: %s, finished: %v",
                t.Id,
                t.Category.String(),
                t.Msg,
                formatDatetime(t.CreatedAt),
                formatDatetime(t.PlannedAt),
                t.Done)
}</span>

func PrintTasks(out io.Writer, tasks ...Task) <span class="cov8" title="1">{
        for _, task := range tasks </span><span class="cov8" title="1">{
                fmt.Fprintln(out, task.String())
        }</span>
}

func WriteToJson(filePath string, tasks ...Task) error <span class="cov8" title="1">{
        if !strings.HasSuffix(filePath, ".json") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid file extension: %s. Expected a .json file", filePath)
        }</span>

        <span class="cov8" title="1">data, err := jsonMarshal(tasks, "", "  ")
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to marshal tasks: %w", err)
        }</span>

        <span class="cov8" title="1">err = os.WriteFile(filePath, data, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to a file '%s': %w", filePath, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ReadTasksFromJSON(filePath string) ([]Task, error) <span class="cov8" title="1">{
        if err := validateJSONFile(filePath); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read file '%s': %w", filePath, err)
        }</span>

        <span class="cov8" title="1">return UnmarshalTasks(data)</span>
}

func UnmarshalTasks(data []byte) ([]Task, error) <span class="cov8" title="1">{
        var tasks []Task
        if err := json.Unmarshal(data, &amp;tasks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>
        <span class="cov8" title="1">return tasks, nil</span>
}

func UnmarshalTask(data []byte) (*Task, error) <span class="cov0" title="0">{
        var task Task
        if err := json.Unmarshal(data, &amp;task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;task, nil</span>
}

func validateJSONFile(filePath string) error <span class="cov8" title="1">{
        ext := filepath.Ext(filePath)
        if ext != ".json" </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid file extension: %s. Expected a .json file", filePath)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package internal

import (
        "errors"
        "fmt"
        "strings"
        "sync"
        "time"
)

const (
        TimeFormat = "2006-01-02T15:04:05Z07:00"
)

var ErrTimeNilPointer = errors.New("time: nil pointer")

type TaskOptional struct {
        Done      *bool         `json:"done"`
        Msg       *string       `json:"msg"`
        Category  *TaskCategory `json:"category"`
        PlannedAt *CustomTime   `json:"plannedAt"`
        // trackerId uuid.UUID
}

func AdapterTaskOptional(task Task) TaskOptional <span class="cov0" title="0">{
        custmTime, err := NewCustomTime(&amp;task.PlannedAt)
        if err != nil &amp;&amp; err != ErrTimeNilPointer </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return TaskOptional{
                Done:      &amp;task.Done,
                Msg:       &amp;task.Msg,
                Category:  &amp;task.Category,
                PlannedAt: custmTime,
        }</span>
}

type CustomTime struct {
        Time time.Time
}

func NewCustomTime(timePtr *time.Time) (*CustomTime, error) <span class="cov0" title="0">{
        if timePtr == nil </span><span class="cov0" title="0">{
                return nil, ErrTimeNilPointer
        }</span> else<span class="cov0" title="0"> {
                return &amp;CustomTime{Time: *timePtr}, nil
        }</span>
}

func (ct *CustomTime) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        s := strings.Trim(string(b), "\"")
        if s == "null" </span><span class="cov0" title="0">{
                ct.Time = time.Time{}
                return nil
        }</span>
        <span class="cov0" title="0">t, err := time.Parse(TimeFormat, s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ct.Time = t
        return nil</span>
}

func (ct *CustomTime) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if ct.Time.IsZero() </span><span class="cov0" title="0">{
                return []byte("null"), nil
        }</span>
        <span class="cov0" title="0">return []byte(fmt.Sprintf("\"%s\"", ct.Time.Format(TimeFormat))), nil</span>
}

func (ct *CustomTime) AsTime() time.Time <span class="cov0" title="0">{
        return ct.Time
}</span>

// mainly to mock test
type TaskServiceInterface interface {
        Read() []Task
        CreateTask(TaskOptional) *Task
        FindTaskById(int) (*Task, error)
        PartialUpdateTask(int, *TaskOptional) error
        DeleteTask(int) error
}

// implements TaskService interface
type TaskHolder struct {
        latestId  int
        Tasks     []Task
        DiskPath  string
        TasksPipe chan Task
        sync.Mutex
}

func NewTaskHolder(diskPath string) *TaskHolder <span class="cov8" title="1">{
        return &amp;TaskHolder{DiskPath: diskPath}
}</span>

func (t *TaskHolder) Read() []Task <span class="cov8" title="1">{
        return append([]Task(nil), t.Tasks...)
}</span>

// returns latestId and len of tasks
func (t *TaskHolder) Count() (int, int) <span class="cov0" title="0">{
        return t.latestId, len(t.Tasks)
}</span>

func (t *TaskHolder) Add(task Task) <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()
        t.latestId++
        // if task.Id &lt; t.latestId {
        //         task.Id = t.latestId
        // }
        t.Tasks = append(t.Tasks, task)

}</span>

func (t *TaskHolder) CreateTask(update TaskOptional) *Task <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()
        t.latestId++

        var msg string
        if update.Msg != nil </span><span class="cov8" title="1">{
                msg = *update.Msg
        }</span>

        <span class="cov8" title="1">var category TaskCategory
        if update.Category != nil </span><span class="cov8" title="1">{
                category = *update.Category
        }</span>

        <span class="cov8" title="1">var plannedAt time.Time
        if update.PlannedAt != nil </span><span class="cov8" title="1">{
                plannedAt = update.PlannedAt.Time
        }</span>

        <span class="cov8" title="1">task := NewTask(t.latestId, msg, category, plannedAt)
        t.Tasks = append(t.Tasks, task)
        return &amp;task</span>
}

func (t *TaskHolder) FindTaskById(taskId int) (*Task, error) <span class="cov8" title="1">{
        for i := range t.Tasks </span><span class="cov8" title="1">{
                if t.Tasks[i].Id == taskId </span><span class="cov8" title="1">{
                        return &amp;t.Tasks[i], nil
                }</span>
        }
        <span class="cov8" title="1">return nil, ErrNotFound</span>
}

func (t *TaskHolder) PartialUpdateTask(taskId int, update *TaskOptional) error <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()
        task, err := t.FindTaskById(taskId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if update.Done != nil </span><span class="cov8" title="1">{
                task.Done = *update.Done
        }</span>

        <span class="cov8" title="1">if update.Msg != nil </span><span class="cov8" title="1">{
                if len(*update.Msg) == 0 </span><span class="cov8" title="1">{
                        return &amp;EmptyTaskValueError{}
                }</span>
                <span class="cov8" title="1">task.Msg = *update.Msg</span>
        }

        <span class="cov8" title="1">if update.Category != nil </span><span class="cov8" title="1">{
                if !isValidTaskCategory(*update.Category) </span><span class="cov8" title="1">{
                        return &amp;InvalidCategoryError{Category: *update.Category}
                }</span>
                <span class="cov8" title="1">task.Category = *update.Category</span>
        }

        <span class="cov8" title="1">if update.PlannedAt != nil </span><span class="cov8" title="1">{
                if update.PlannedAt.Time.Before(time.Now()) </span><span class="cov8" title="1">{
                        return &amp;PastPlannedTimeError{PlannedTime: *&amp;update.PlannedAt.Time}
                }</span>
                <span class="cov8" title="1">task.PlannedAt = *&amp;update.PlannedAt.Time</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (t *TaskHolder) DeleteTask(taskId int) error <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()
        index := -1
        topId := -1
        for i, task := range t.Tasks </span><span class="cov8" title="1">{
                if task.Id == taskId </span><span class="cov8" title="1">{
                        index = i

                }</span>
                <span class="cov8" title="1">if task.Id &gt; topId </span><span class="cov8" title="1">{
                        topId = task.Id
                }</span>
        }

        <span class="cov8" title="1">if index == -1 </span><span class="cov8" title="1">{
                return fmt.Errorf("task with ID %d not found", taskId)
        }</span>

        // deletedIndex = t.Tasks[index]
        <span class="cov8" title="1">t.Tasks = append(t.Tasks[:index], t.Tasks[index+1:]...)

        return nil</span>
}

func isValidTaskCategory(category TaskCategory) bool <span class="cov8" title="1">{
        return Brewing &lt;= category &amp;&amp; category &lt;= Quality
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package internal

import (
        "fmt"

        "github.com/google/uuid"
)

type TaskRequest struct {
        Operation  string
        Task       TaskOptional
        TaskId     int
        trackingId uuid.UUID
}

type TaskResult struct {
        Task  *Task
        Error error
}

type Worker struct {
        id         int
        taskHolder *TaskHolder
        request    &lt;-chan TaskRequest
        result     chan&lt;- TaskResult
        quit       chan bool
}

type WorkerPool struct {
        workers []Worker
        // wg      sync.WaitGroup
}

type ConcurrentTaskService struct {
        TaskHolder   *TaskHolder
        taskRequests chan&lt;- TaskRequest
        results      &lt;-chan TaskResult
        workerPool   WorkerPool
}

func (w *Worker) Start() <span class="cov0" title="0">{
        // fmt.Printf("Start worker %d\n", w.id)
        for </span><span class="cov0" title="0">{
                select </span>{
                case req, ok := &lt;-w.request:<span class="cov0" title="0">
                        // fmt.Println("Handling request by", w.id)
                        if !ok </span><span class="cov0" title="0">{
                                // fmt.Println("Channel not ok")
                                return
                        }</span>
                        <span class="cov0" title="0">result := w.processRequest(req)
                        w.result &lt;- result</span>
                case &lt;-w.quit:<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (w *Worker) Stop() <span class="cov0" title="0">{
        close(w.quit)
}</span>

func (w *Worker) processRequest(req TaskRequest) TaskResult <span class="cov0" title="0">{
        switch req.Operation </span>{
        case "CREATE":<span class="cov0" title="0">
                // fmt.Println("Worker calls holder to create task", w.id)
                task := w.taskHolder.CreateTask(req.Task)
                return TaskResult{Task: task}</span>
        default:<span class="cov0" title="0">
                return TaskResult{Error: fmt.Errorf("unknown operation: %s", req.Operation)}</span>
        }
}

func NewWorkerPool(numWorkers int, taskHolder *TaskHolder, taskRequests &lt;-chan TaskRequest, taskResponse chan&lt;- TaskResult) WorkerPool <span class="cov0" title="0">{
        // fmt.Println("Init NewWorkerPool")
        var workers []Worker
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov0" title="0">{
                workers = append(workers, Worker{
                        id:         i,
                        taskHolder: taskHolder,
                        request:    taskRequests,
                        result:     taskResponse,
                        quit:       make(chan bool),
                })
        }</span>
        <span class="cov0" title="0">return WorkerPool{ // composite literal
                workers: workers,
        }</span>
}

func (wp *WorkerPool) Start() <span class="cov0" title="0">{
        for i := range wp.workers </span><span class="cov0" title="0">{
                go wp.workers[i].Start()
        }</span>
}

func (wp *WorkerPool) Close() <span class="cov0" title="0">{
        for _, worker := range wp.workers </span><span class="cov0" title="0">{
                worker.Stop()
        }</span>
}

func NewConcurrentTaskService(t *TaskHolder) *ConcurrentTaskService <span class="cov0" title="0">{
        // fmt.Println("Init NewConcurrentTaskService")
        taskRequests := make(chan TaskRequest)
        results := make(chan TaskResult)
        pool := NewWorkerPool(5, t, taskRequests, results)
        service := &amp;ConcurrentTaskService{
                TaskHolder:   t,
                taskRequests: taskRequests,
                results:      results,
                workerPool:   pool,
        }
        service.workerPool.Start()

        return service
}</span>

func (t *ConcurrentTaskService) CloseAll() <span class="cov0" title="0">{
        // close(t.results)
        close(t.taskRequests)

}</span>

func (t *ConcurrentTaskService) CreateTask(task TaskOptional) *Task <span class="cov0" title="0">{
        // fmt.Println("Create task pushed on taskrequest channel", task)
        // t.taskRequests &lt;- TaskRequest{Operation: "CREATE", Task: task}
        // result := &lt;-t.results

        return t.TaskHolder.CreateTask(task)
}</span>

func (t *ConcurrentTaskService) Add(task Task) <span class="cov0" title="0">{
        t.TaskHolder.Add(task)
}</span>

func (t *ConcurrentTaskService) FindTaskById(taskId int) (*Task, error) <span class="cov0" title="0">{
        return t.TaskHolder.FindTaskById(taskId)
}</span>

func (t *ConcurrentTaskService) PartialUpdateTask(taskId int, update *TaskOptional) error <span class="cov0" title="0">{
        return t.TaskHolder.PartialUpdateTask(taskId, update)
}</span>

func (t *ConcurrentTaskService) DeleteTask(taskId int) error <span class="cov0" title="0">{
        return t.TaskHolder.DeleteTask(taskId)
}</span>

// returns latestId and len of tasks
func (t *ConcurrentTaskService) Count() (int, int) <span class="cov0" title="0">{
        return t.TaskHolder.Count()
}</span>

func (t *ConcurrentTaskService) Read() []Task <span class="cov0" title="0">{
        return t.TaskHolder.Read()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package internal

import (
        "bytes"
        "io"
        "os"
        "testing"
        "time"
)

var MockTime = time.Date(2023, 7, 23, 12, 0, 0, 0, time.UTC).Truncate(0)

func ProvideMocktimeNow(t *testing.T) func() time.Time <span class="cov8" title="1">{
        originalTimeNow := timeNow
        t.Cleanup(func() </span><span class="cov8" title="1">{
                timeNow = originalTimeNow
        }</span>)
        <span class="cov8" title="1">return func() time.Time </span><span class="cov8" title="1">{
                return MockTime
        }</span>
}

func ProvideTask(t *testing.T) Task <span class="cov8" title="1">{
        return NewTask(1, "task_my_task", 1, MockTime)
}</span>

func ProvideTaskHolder() *TaskHolder <span class="cov8" title="1">{
        th := NewTaskHolder("resources/cli_disk_test.json")
        updt := TaskOptional{
                nil,
                StringPtr("Initial Task"),
                CategoryPtr(Brewing),
                TimePtr(time.Now().Add(24 * time.Hour)),
        }

        th.CreateTask(updt)
        return th
}</span>

func ProvideTaskHolderWithPath(path string) *TaskHolder <span class="cov8" title="1">{
        th := NewTaskHolder(path)
        updt := TaskOptional{
                nil,
                StringPtr("Initial Task"),
                CategoryPtr(Brewing),
                TimePtr(time.Now().Add(24 * time.Hour)),
        }
        th.CreateTask(updt)
        return th
}</span>
func MockNewTaskHolder(diskPath string) *TaskHolder <span class="cov8" title="1">{

        th := NewTaskHolder("resources/cli_disk_test.json")
        updt := TaskOptional{
                nil,
                StringPtr("Initial Task"),
                CategoryPtr(Brewing),
                TimePtr(time.Now().Add(24 * time.Hour)),
        }
        th.CreateTask(updt)
        return th
}</span>

func ReadCapturedStdout(r *os.File) string <span class="cov8" title="1">{
        var buf bytes.Buffer
        io.Copy(&amp;buf, r)
        output := buf.String()
        return output
}</span>

func WriteToCapturedStdin(write *os.File, cmnds []string) <span class="cov0" title="0">{
        time.Sleep(100 * time.Millisecond)
        for _, cmnd := range cmnds </span><span class="cov0" title="0">{
                write.Write([]byte(cmnd))
                time.Sleep(100 * time.Millisecond)
        }</span>
}

// Restore after capturing
func RestoreStdout(w *os.File, oldStdout *os.File) <span class="cov8" title="1">{
        w.Close()
        os.Stdout = oldStdout
}</span>

// Restore after capturing
func RestoreStdin(r *os.File, oldStdin *os.File) <span class="cov8" title="1">{
        r.Close()
        os.Stdin = oldStdin
}</span>

// Capture stdout. DON'T FORGET TO RESTORE!
func CaptureStdout() (oldStdout *os.File, read *os.File, write *os.File) <span class="cov8" title="1">{
        oldStdout = os.Stdout
        read, write, _ = os.Pipe()
        os.Stdout = write
        return
}</span>

// Capture stdin. DON'T FORGET TO RESTORE!
func CaptureStdin() (oldStdin *os.File, read *os.File, write *os.File) <span class="cov8" title="1">{
        oldStdin = os.Stdin
        read, write, _ = os.Pipe()
        os.Stdin = read
        return
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package internal

import (
        "embed"
        "fmt"
        "io/fs"
        "math/rand"
        "strings"
        "time"
)

//go:embed resources
var resourcesFiles embed.FS

var timeNow = time.Now

func check(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
}

func formatDatetime(t time.Time) string <span class="cov8" title="1">{
        return t.Format("Monday, January 2, 2006 at 15:04")
}</span>

func GenerateRandomTasks(count int) []Task <span class="cov8" title="1">{
        brewingVerbs := []string{"Brew", "Ferment", "Bottle", "Label", "Clean", "Inspect", "Order", "Taste"}
        adjectives := []string{"Hoppy", "Malty", "Crisp", "Smooth", "Tangy", "Barrel-aged", "Experimental", "Funky", "Juicy", "Hazy", "Robust", "Refreshing"}
        beerTypes := []string{"IPA", "Stout", "Lager", "Wheat Beer", "Pale Ale", "Porter", "Sour", "Seasonal Batch"}
        ingredients := []string{"Hops", "Malt", "Yeast", "Fruit puree", "Spices", "Coffee beans", "Cocoa nibs", "Oak chips"}
        marketingTasks := []string{"Design new label", "Plan social media campaign", "Organize tasting event", "Create promotional video", "Update website", "Develop brand partnership", "Analyze market trends", "Conduct customer survey"}
        logisticsTasks := []string{"Schedule delivery route", "Inventory check", "Restock supplies", "Maintain delivery vehicles", "Optimize warehouse layout", "Negotiate with suppliers", "Update inventory management system", "Coordinate with distributors"}
        qualityTasks := []string{"Conduct sensory analysis", "Calibrate testing equipment", "Review quality control procedures", "Train staff on quality standards", "Perform microbiological testing", "Update quality assurance documentation", "Conduct supplier quality audit", "Implement new quality control measure"}

        tasks := make([]Task, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                var taskValue string
                var category TaskCategory
                x := rand.Intn(5)
                switch x </span>{
                case 0:<span class="cov0" title="0">
                        verb := brewingVerbs[rand.Intn(len(brewingVerbs))]
                        adj := adjectives[rand.Intn(len(adjectives))]
                        noun := beerTypes[rand.Intn(len(beerTypes))]
                        taskValue = strings.Join([]string{verb, adj, noun}, " ")
                        category = Brewing</span>
                case 1:<span class="cov8" title="1">
                        verb := "Process"
                        if rand.Intn(2) == 0 </span><span class="cov8" title="1">{
                                verb = "Order"
                        }</span>
                        <span class="cov8" title="1">ingredient := ingredients[rand.Intn(len(ingredients))]
                        quantity := rand.Intn(500) + 1 // 1 to 500
                        unit := "kg"
                        if rand.Intn(2) == 0 </span><span class="cov8" title="1">{
                                unit = "lbs"
                        }</span>
                        <span class="cov8" title="1">taskValue = fmt.Sprintf("%s %d %s of %s", verb, quantity, unit, ingredient)
                        category = Brewing</span>
                case 2:<span class="cov8" title="1">
                        taskValue = marketingTasks[rand.Intn(len(marketingTasks))]
                        category = Marketing</span>
                case 3:<span class="cov8" title="1">
                        taskValue = logisticsTasks[rand.Intn(len(logisticsTasks))]
                        category = Logistics</span>
                case 4:<span class="cov0" title="0">
                        taskValue = qualityTasks[rand.Intn(len(qualityTasks))]
                        category = Quality</span>

                }
                <span class="cov8" title="1">plannedAt := time.Now().Add(time.Duration(rand.Intn(24*30)) * time.Hour)
                newTask := NewTask(i, taskValue, category, plannedAt)
                tasks[i] = newTask</span>
        }
        <span class="cov8" title="1">return tasks</span>
}

func BeerAscii() string <span class="cov8" title="1">{
        data, err := fs.ReadFile(resourcesFiles, "resources/beer.txt")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("error happened while reading beer logo: ", err)
                return ""
        }</span>
        <span class="cov8" title="1">return string(data)</span>
}

func StringPtr(s string) *string <span class="cov8" title="1">{
        if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;s</span>
}

func CategoryPtr(c TaskCategory) *TaskCategory <span class="cov8" title="1">{
        return &amp;c
}</span>

func TimePtr(t time.Time) *CustomTime <span class="cov8" title="1">{
        return &amp;CustomTime{t}
}</span>

func BoolPtr(b bool) *bool <span class="cov0" title="0">{
        return &amp;b
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package logger

import (
        "log"
        "os"
)

var (
        Info  *log.Logger
        Error *log.Logger
)

func init() <span class="cov8" title="1">{
        // Set up Info logger
        Info = log.New(os.Stdout, "INFO: ", log.Ldate|log.Ltime|log.Lshortfile)

        // Set up Error logger
        Error = log.New(os.Stderr, "ERROR: ", log.Ldate|log.Ltime|log.Lshortfile)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package view

import (
        "embed"
        "fmt"
        "html/template"
        "net/http"
        "strings"
        "time"

        "github.com/zhekagigs/golang_todo/internal"
        "github.com/zhekagigs/golang_todo/logger"
)

//go:embed templates/*.html
var templateFiles embed.FS

// type TemplateData struct {
//         Tasks []in.Task
// }

type Renderer interface {
        RenderTaskList(http.ResponseWriter, []internal.Task) error
        RenderCreateForm(http.ResponseWriter) error
        RenderTaskUpdate(http.ResponseWriter, *internal.Task) error
}

type TaskRenderer struct {
        templates *template.Template
}

type TaskListData struct {
        Tasks []internal.Task
}

func renderErrCheck(err error) error <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error rendering template: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func NewRenderer() (*TaskRenderer, error) <span class="cov8" title="1">{
        funcMap := template.FuncMap{
                "formatDate": func(t time.Time) string </span><span class="cov8" title="1">{
                        return t.Format("Jan 02, 2006 15:04")
                }</span>,
                "toLowerCase": strings.ToLower,
        }

        <span class="cov8" title="1">tmpl, err := template.New("").Funcs(funcMap).ParseFS(templateFiles, "templates/*.html")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;TaskRenderer{templates: tmpl}, nil</span>
}

func (r *TaskRenderer) RenderTaskList(w http.ResponseWriter, tasks []internal.Task) error <span class="cov8" title="1">{
        logger.Info.Printf("Rendering Task List")
        data := TaskListData{
                Tasks: tasks,
        }

        err := r.templates.ExecuteTemplate(w, "index.html", data)
        return renderErrCheck(err)
}</span>

func (r *TaskRenderer) RenderCreateForm(w http.ResponseWriter) error <span class="cov8" title="1">{
        err := r.templates.ExecuteTemplate(w, "create.html", nil)
        return renderErrCheck(err)
}</span>

func (r *TaskRenderer) RenderTaskUpdate(w http.ResponseWriter, task *internal.Task) error <span class="cov8" title="1">{
        logger.Info.Println("Rendering update task form")
        data := struct {
                Task *internal.Task
        }{
                Task: task,
        }
        err := r.templates.ExecuteTemplate(w, "update.html", data)
        return renderErrCheck(err)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
