
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>golang_todo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/zhekagigs/golang_todo/cli.go (82.9%)</option>
				
				<option value="file1">github.com/zhekagigs/golang_todo/main.go (81.1%)</option>
				
				<option value="file2">github.com/zhekagigs/golang_todo/task.go (80.8%)</option>
				
				<option value="file3">github.com/zhekagigs/golang_todo/taskHolder.go (100.0%)</option>
				
				<option value="file4">github.com/zhekagigs/golang_todo/utils.go (74.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"
)

type commands string

const (
        READ   commands = "read"
        CREATE commands = "create"
        UPDATE commands = "update"
        DELETE commands = "delete"
        EXIT   commands = "exit"
)

func RunTaskManagmentCLI(taskHolder *TaskHolder) int <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        for </span><span class="cov0" title="0">{
                displayCommands()
                cmd, taskId, err := parseCommand(reader)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        continue</span>
                }

                <span class="cov0" title="0">if exitCode := executeCommand(cmd, taskId, taskHolder, reader); exitCode != -1 </span><span class="cov0" title="0">{
                        return exitCode
                }</span>
        }
}

func displayCommands() <span class="cov0" title="0">{
        fmt.Println("\nAvailable Commands: read, create, update, delete, exit")
        fmt.Print("Enter Command: ")
}</span>

func parseCommand(reader *bufio.Reader) (commands, int, error) <span class="cov8" title="1">{
        cmdString, _ := reader.ReadString('\n')
        parts := strings.Fields(cmdString)
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return "", 0, fmt.Errorf("Please enter a command.")
        }</span>

        <span class="cov8" title="1">cmd := commands(strings.TrimSpace(strings.ToLower(parts[0])))

        var taskId int
        var err error
        if len(parts) &gt; 1 &amp;&amp; (cmd == UPDATE || cmd == DELETE) </span><span class="cov8" title="1">{
                taskId, err = strconv.Atoi(parts[1])
                if err != nil </span><span class="cov8" title="1">{
                        return "", 0, fmt.Errorf("Invalid task ID. Please enter a number.")
                }</span>
        }

        <span class="cov8" title="1">return cmd, taskId, nil</span>
}

func executeCommand(cmd commands, taskId int, taskHolder *TaskHolder, reader *bufio.Reader) int <span class="cov8" title="1">{
        var err error
        switch cmd </span>{
        case READ:<span class="cov8" title="1">
                readTasks(taskHolder)</span>
        case CREATE:<span class="cov8" title="1">
                err = createTask(taskHolder, reader)</span>
        case UPDATE:<span class="cov8" title="1">
                err = updateTask(taskHolder, taskId, reader)</span>
        case DELETE:<span class="cov8" title="1">
                err = deleteTask(taskHolder, taskId)</span>
        case EXIT:<span class="cov8" title="1">
                return exitApp(taskHolder)</span>
        default:<span class="cov0" title="0">
                fmt.Println("Invalid command. Please try again.")</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed operation with error: ", err)
        }</span>

        <span class="cov8" title="1">return -1</span> // Continue the loop
}

func exitApp(taskHolder *TaskHolder) int <span class="cov8" title="1">{
        fmt.Println("Thank you for using the Task Management CLI. Tasks are saved to `resources/disk.json`. Goodbye!")
        err := WriteToJson("resources/disk.json", taskHolder.tasks...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return 0</span>
}

func deleteTask(taskHolder *TaskHolder, taskId int) error <span class="cov8" title="1">{
        err := taskHolder.DeleteTask(taskId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return err</span>
}

func updateTask(taskHolder *TaskHolder, taskId int, reader *bufio.Reader) error <span class="cov8" title="1">{
        fmt.Println("Updating task. Press Enter to skip a field if you don't want to update it.")

        // Update task message
        fmt.Print("Enter new task description (or press Enter to skip): ")
        msg, _ := reader.ReadString('\n')
        msg = strings.TrimSpace(msg)

        // Update task status
        var done bool
        var donePtr *bool
        fmt.Print("Update task status? (y/n): ")
        updateStatus, _ := reader.ReadString('\n')
        if strings.ToLower(strings.TrimSpace(updateStatus)) == "y" </span><span class="cov8" title="1">{
                fmt.Print("Is the task done? (true/false): ")
                doneStr, _ := reader.ReadString('\n')
                doneStr = strings.TrimSpace(doneStr)
                if parsedDone, err := strconv.ParseBool(doneStr); err == nil </span><span class="cov8" title="1">{
                        done = parsedDone
                        donePtr = &amp;done
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        // Update task category
        <span class="cov8" title="1">var category TaskCategory
        var categoryPtr *TaskCategory
        fmt.Print("Update task category? (y/n): ")
        updateCategory, _ := reader.ReadString('\n')
        if strings.ToLower(strings.TrimSpace(updateCategory)) == "y" </span><span class="cov8" title="1">{
                fmt.Println("Available categories:")
                fmt.Println("0: Brewing")
                fmt.Println("1: Marketing")
                fmt.Println("2: Logistics")
                fmt.Println("3: Quality")
                fmt.Print("Enter new category (0-3): ")
                categoryStr, _ := reader.ReadString('\n')
                if parsedCategory, err := strconv.Atoi(strings.TrimSpace(categoryStr)); err == nil &amp;&amp; parsedCategory &gt;= 0 &amp;&amp; parsedCategory &lt;= 3 </span><span class="cov8" title="1">{
                        category = TaskCategory(parsedCategory)
                        categoryPtr = &amp;category
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        // Update planned time
        <span class="cov8" title="1">var plannedAt time.Time
        var plannedAtPtr *time.Time
        fmt.Print("Update planned time? (y/n): ")
        updatePlannedTime, _ := reader.ReadString('\n')
        if strings.ToLower(strings.TrimSpace(updatePlannedTime)) == "y" </span><span class="cov8" title="1">{
                fmt.Print("Enter new planned time (YYYY-MM-DD HH:MM): ")
                timeStr, _ := reader.ReadString('\n')
                if parsedTime, err := time.Parse(TASK_TIME_FORMAT, strings.TrimSpace(timeStr)); err == nil </span><span class="cov8" title="1">{
                        plannedAt = parsedTime
                        plannedAtPtr = &amp;plannedAt
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        <span class="cov8" title="1">update := TaskUpdate{
                Done:      donePtr,
                Msg:       stringPtr(msg),
                Category:  categoryPtr,
                PlannedAt: plannedAtPtr,
        }

        err := taskHolder.PartialUpdateTask(taskId, update)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error updating task: %v\n", err)
                return err
        }</span> else<span class="cov8" title="1"> {
                fmt.Println("Task updated successfully.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func createTask(taskHolder *TaskHolder, reader *bufio.Reader) error <span class="cov8" title="1">{

        fmt.Println("Enter new task on one line in a format 'task, category, planned to finish date'")
        fmt.Println("Available categories:")
        fmt.Println("0: Brewing")
        fmt.Println("1: Marketing")
        fmt.Println("2: Logistics")
        fmt.Println("3: Quality")
        fmt.Println("Format time (YYYY-MM-DD HH:MM)")
        fmt.Println("Example: `Finish brewing IPA, 0, 2024-08-29 14:27`")

        line, err := reader.ReadString('\n') //TODO unignore errors
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">lines := strings.Split(line, ",")

        taskValue := lines[0]
        categoryNum, err := strconv.Atoi(strings.TrimSpace(lines[1]))
        fmt.Println(categoryNum)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">plannedAt := lines[2]
        var plannedParsedAt time.Time
        parsedTime, err := time.Parse(TASK_TIME_FORMAT, strings.TrimSpace(plannedAt))
        if err == nil </span><span class="cov8" title="1">{
                plannedParsedAt = parsedTime
        }</span>
        <span class="cov8" title="1">taskHolder.CreateTask(taskValue, TaskCategory(categoryNum), plannedParsedAt)
        return nil</span>
}

func readTasks(taskHolder *TaskHolder) <span class="cov8" title="1">{
        all_tasks := taskHolder.Read()
        if len(all_tasks) == 0 </span><span class="cov8" title="1">{
                fmt.Println("No tasks found.")
                return
        }</span>

        <span class="cov8" title="1">fmt.Printf("\nList of tasks:\n\n")
        PrintTasks(os.Stdout, all_tasks...)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "errors"
        "flag"
        "fmt"
        "os"
)

func main() <span class="cov0" title="0">{
        os.Exit(RealMain())
}</span>



func RealMain() int <span class="cov0" title="0">{
        taskHolder, checkExit, exitCode := InitialMain()
        if checkExit </span><span class="cov0" title="0">{
                return exitCode
        }</span>

        // runs main CLI routine
        <span class="cov0" title="0">returnCode := RunTaskManagmentCLI(taskHolder)

        return returnCode</span>
}

func InitialMain() (*TaskHolder, bool, int) <span class="cov8" title="1">{
        helpFlag := flag.Bool("h", false, "Help is here")

        flag.Usage = printHelp

        flag.Parse()

        if *helpFlag </span><span class="cov8" title="1">{
                flag.Usage()
                return nil, true, 0
        }</span>

        <span class="cov8" title="1">if flag.NArg() &lt; 1 </span><span class="cov8" title="1">{
                fmt.Println("Error: JSON file path is required")
                flag.Usage()
                return nil, true, 1
        }</span>

        <span class="cov8" title="1">fileName := flag.Arg(0)

        savedTasks, err := ReadFromJson(fileName)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, os.ErrNotExist):<span class="cov0" title="0">
                        fmt.Println("Error: Wrong file path")</span>
                default:<span class="cov8" title="1">
                        fmt.Printf("Error while reading json file: %v\n", err)</span>
                }
                <span class="cov8" title="1">flag.Usage()
                return nil, true, 1</span>
        }
        <span class="cov8" title="1">fmt.Println(BeerAscii())
        fmt.Printf("\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Microbrewery Tasks Application&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n\n")
        PrintTasks(os.Stdout, savedTasks...)
        taskHolder := NewTaskHolder()
        for _, task := range savedTasks </span><span class="cov8" title="1">{
                taskHolder.Add(task)
        }</span>
        <span class="cov8" title="1">return taskHolder, false, 0</span>
}

func printHelp() <span class="cov8" title="1">{
        fmt.Println("Usage: microbrewery-tasks [options] &lt;json-file-path&gt;")
        fmt.Println("\nOptions:")
        flag.PrintDefaults()
        fmt.Println("\nDescription:")
        fmt.Println("  This CLI application reads a JSON file containing microbrewery tasks and displays them.")
        fmt.Println("  Provide the path to the JSON file as an argument.")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "strings"
        "time"
)

const TASK_TIME_FORMAT = "2006-01-02 15:04"

var jsonMarshal = json.MarshalIndent //for monkey patching mock

// error definitions
var (
        ErrNotFound = errors.New("not found")
)

type InvalidCategoryError struct {
        Category TaskCategory
}

func (e *InvalidCategoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("invalid task category: %v", e.Category)
}</span>

type EmptyTaskValueError struct{}

func (e *EmptyTaskValueError) Error() string <span class="cov0" title="0">{
        return "task value cannot be empty"
}</span>

type PastPlannedTimeError struct {
        PlannedTime time.Time
}

func (e *PastPlannedTimeError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("planned time %v is in the past", e.PlannedTime)
}</span>

type TaskCategory int

const (
        Brewing TaskCategory = iota
        Marketing
        Logistics
        Quality
)

func (tc TaskCategory) String() string <span class="cov8" title="1">{
        return [...]string{"Brewing", "Marketing", "Logistics", "Quality"}[tc]
}</span>

type Task struct {
        Id        int
        Msg       string
        Category  TaskCategory
        Done      bool
        CreatedAt time.Time
        PlannedAt time.Time
}

func NewTask(id int, task string, category TaskCategory, plannedAt time.Time) Task <span class="cov8" title="1">{
        return Task{
                Id:        id,
                Msg:       task,
                Category:  category,
                Done:      false,
                CreatedAt: timeNow().Round(0),
                PlannedAt: plannedAt.Round(0),
        }
}</span>

func (t *Task) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("id:%d,[%s] %s, created: %s, planned: %s, finished: %v",
                t.Id,
                t.Category.String(),
                t.Msg,
                formatDatetime(t.CreatedAt),
                formatDatetime(t.PlannedAt),
                t.Done)
}</span>

func PrintTasks(out io.Writer, tasks ...Task) <span class="cov8" title="1">{
        for _, task := range tasks </span><span class="cov8" title="1">{
                fmt.Fprintln(out, task.String())
        }</span>
}

func WriteToJson(filePath string, tasks ...Task) error <span class="cov8" title="1">{
        if !strings.HasSuffix(filePath, ".json") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid file extension: %s. Expected a .json file", filePath)
        }</span>

        <span class="cov8" title="1">data, err := jsonMarshal(tasks, "", "  ")
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to marshal tasks: %w", err)
        }</span>

        <span class="cov8" title="1">err = os.WriteFile(filePath, data, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to a file '%s': %w", filePath, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ReadFromJson(filePath string) ([]Task, error) <span class="cov8" title="1">{
        if !strings.HasSuffix(filePath, ".json") </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid file extension: %s. Expected a .json file", filePath)
        }</span>

        <span class="cov8" title="1">bytes, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read a file '%s': %w", filePath, err)
        }</span>

        <span class="cov8" title="1">var tasks []Task
        if err := json.Unmarshal(bytes, &amp;tasks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON from file '%s': %w", filePath, err)
        }</span>

        <span class="cov8" title="1">return tasks, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "time"
)

type TaskUpdate struct {
        Done      *bool
        Msg       *string
        Category  *TaskCategory
        PlannedAt *time.Time
}

type TaskHolder struct {
        latestId int
        tasks    []Task
}

func NewTaskHolder() *TaskHolder <span class="cov8" title="1">{
        return &amp;TaskHolder{}
}</span>

func (t *TaskHolder) Read() []Task <span class="cov8" title="1">{
        return t.tasks
}</span>

func (t *TaskHolder) Add(task Task) <span class="cov8" title="1">{
        t.latestId++
        if task.Id &lt; t.latestId </span><span class="cov8" title="1">{
                task.Id = t.latestId
        }</span>
        <span class="cov8" title="1">t.tasks = append(t.tasks, task)</span>

}

func (t *TaskHolder) CreateTask(taskValue string, category TaskCategory, plannedAt time.Time) *Task <span class="cov8" title="1">{
        t.latestId++
        task := NewTask(t.latestId, taskValue, category, plannedAt)
        t.tasks = append(t.tasks, task)
        return &amp;task
}</span>

func (t *TaskHolder) FindTaskById(taskId int) (*Task, error) <span class="cov8" title="1">{
        for i := range t.tasks </span><span class="cov8" title="1">{
                if t.tasks[i].Id == taskId </span><span class="cov8" title="1">{
                        return &amp;t.tasks[i], nil
                }</span>
        }
        <span class="cov8" title="1">return nil, ErrNotFound</span>
}

func (t *TaskHolder) PartialUpdateTask(taskId int, update TaskUpdate) error <span class="cov8" title="1">{
        task, err := t.FindTaskById(taskId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if update.Done != nil </span><span class="cov8" title="1">{
                task.Done = *update.Done
        }</span>

        <span class="cov8" title="1">if update.Msg != nil </span><span class="cov8" title="1">{
                if len(*update.Msg) == 0 </span><span class="cov8" title="1">{
                        return &amp;EmptyTaskValueError{}
                }</span>
                <span class="cov8" title="1">task.Msg = *update.Msg</span>
        }

        <span class="cov8" title="1">if update.Category != nil </span><span class="cov8" title="1">{
                if !isValidTaskCategory(*update.Category) </span><span class="cov8" title="1">{
                        return &amp;InvalidCategoryError{Category: *update.Category}
                }</span>
                <span class="cov8" title="1">task.Category = *update.Category</span>
        }

        <span class="cov8" title="1">if update.PlannedAt != nil </span><span class="cov8" title="1">{
                if update.PlannedAt.Before(time.Now()) </span><span class="cov8" title="1">{
                        return &amp;PastPlannedTimeError{PlannedTime: *update.PlannedAt}
                }</span>
                <span class="cov8" title="1">task.PlannedAt = *update.PlannedAt</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (t *TaskHolder) DeleteTask(taskId int) error <span class="cov8" title="1">{
        index := -1
        for i, task := range t.tasks </span><span class="cov8" title="1">{
                if task.Id == taskId </span><span class="cov8" title="1">{
                        index = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if index == -1 </span><span class="cov8" title="1">{
                return fmt.Errorf("task with ID %d not found", taskId)
        }</span>

        <span class="cov8" title="1">t.tasks = append(t.tasks[:index], t.tasks[index+1:]...)

        return nil</span>
}

func isValidTaskCategory(category TaskCategory) bool <span class="cov8" title="1">{
        return Brewing &lt;= category &amp;&amp; category &lt;= Quality
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"
        "math/rand"
        "os"
        "strings"
        "time"
)

var timeNow = time.Now

func check(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
}

func formatDatetime(t time.Time) string <span class="cov8" title="1">{
        return t.Format("Monday, January 2, 2006 at 15:04")
}</span>

func generateRandomTasks(count int) []Task <span class="cov8" title="1">{
        brewingVerbs := []string{"Brew", "Ferment", "Bottle", "Label", "Clean", "Inspect", "Order", "Taste"}
        adjectives := []string{"Hoppy", "Malty", "Crisp", "Smooth", "Tangy", "Barrel-aged", "Experimental", "Funky", "Juicy", "Hazy", "Robust", "Refreshing"}
        beerTypes := []string{"IPA", "Stout", "Lager", "Wheat Beer", "Pale Ale", "Porter", "Sour", "Seasonal Batch"}
        ingredients := []string{"Hops", "Malt", "Yeast", "Fruit puree", "Spices", "Coffee beans", "Cocoa nibs", "Oak chips"}
        marketingTasks := []string{"Design new label", "Plan social media campaign", "Organize tasting event", "Create promotional video", "Update website", "Develop brand partnership", "Analyze market trends", "Conduct customer survey"}
        logisticsTasks := []string{"Schedule delivery route", "Inventory check", "Restock supplies", "Maintain delivery vehicles", "Optimize warehouse layout", "Negotiate with suppliers", "Update inventory management system", "Coordinate with distributors"}
        qualityTasks := []string{"Conduct sensory analysis", "Calibrate testing equipment", "Review quality control procedures", "Train staff on quality standards", "Perform microbiological testing", "Update quality assurance documentation", "Conduct supplier quality audit", "Implement new quality control measure"}

        tasks := make([]Task, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                var taskValue string
                var category TaskCategory
                x := rand.Intn(5)
                switch x </span>{
                case 0:<span class="cov8" title="1">
                        verb := brewingVerbs[rand.Intn(len(brewingVerbs))]
                        adj := adjectives[rand.Intn(len(adjectives))]
                        noun := beerTypes[rand.Intn(len(beerTypes))]
                        taskValue = strings.Join([]string{verb, adj, noun}, " ")
                        category = Brewing</span>
                case 1:<span class="cov0" title="0">
                        verb := "Process"
                        if rand.Intn(2) == 0 </span><span class="cov0" title="0">{
                                verb = "Order"
                        }</span>
                        <span class="cov0" title="0">ingredient := ingredients[rand.Intn(len(ingredients))]
                        quantity := rand.Intn(500) + 1 // 1 to 500
                        unit := "kg"
                        if rand.Intn(2) == 0 </span><span class="cov0" title="0">{
                                unit = "lbs"
                        }</span>
                        <span class="cov0" title="0">taskValue = fmt.Sprintf("%s %d %s of %s", verb, quantity, unit, ingredient)
                        category = Brewing</span>
                case 2:<span class="cov8" title="1">
                        taskValue = marketingTasks[rand.Intn(len(marketingTasks))]
                        category = Marketing</span>
                case 3:<span class="cov8" title="1">
                        taskValue = logisticsTasks[rand.Intn(len(logisticsTasks))]
                        category = Logistics</span>
                case 4:<span class="cov0" title="0">
                        taskValue = qualityTasks[rand.Intn(len(qualityTasks))]
                        category = Quality</span>

                }
                <span class="cov8" title="1">plannedAt := time.Now().Add(time.Duration(rand.Intn(24*30)) * time.Hour)
                newTask := NewTask(i, taskValue, category, plannedAt)
                tasks[i] = newTask</span>
        }
        <span class="cov8" title="1">return tasks</span>
}

func BeerAscii() string <span class="cov8" title="1">{
        data, err := os.ReadFile("resources/beer.txt")
        check(err)
        return string(data)
}</span>

func stringPtr(s string) *string <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;s</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
