
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>analytics: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/zhekagigs/golang_todo/analytics/analytics.go (0.0%)</option>
				
				<option value="file1">github.com/zhekagigs/golang_todo/analytics/coordinator.go (0.0%)</option>
				
				<option value="file2">github.com/zhekagigs/golang_todo/analytics/rpc.go (0.0%)</option>
				
				<option value="file3">github.com/zhekagigs/golang_todo/analytics/wordCount.go (100.0%)</option>
				
				<option value="file4">github.com/zhekagigs/golang_todo/analytics/worker.go (0.0%)</option>
				
				<option value="file5">github.com/zhekagigs/golang_todo/cli/cli.go (72.6%)</option>
				
				<option value="file6">github.com/zhekagigs/golang_todo/cmd/main.go (60.5%)</option>
				
				<option value="file7">github.com/zhekagigs/golang_todo/controller/api.go (22.9%)</option>
				
				<option value="file8">github.com/zhekagigs/golang_todo/controller/auth.go (0.0%)</option>
				
				<option value="file9">github.com/zhekagigs/golang_todo/controller/serv.go (0.0%)</option>
				
				<option value="file10">github.com/zhekagigs/golang_todo/controller/task_handler.go (66.7%)</option>
				
				<option value="file11">github.com/zhekagigs/golang_todo/internal/task.go (67.6%)</option>
				
				<option value="file12">github.com/zhekagigs/golang_todo/internal/taskHolder.go (69.4%)</option>
				
				<option value="file13">github.com/zhekagigs/golang_todo/internal/taskService.go (0.0%)</option>
				
				<option value="file14">github.com/zhekagigs/golang_todo/internal/testutils.go (88.4%)</option>
				
				<option value="file15">github.com/zhekagigs/golang_todo/internal/utils.go (84.6%)</option>
				
				<option value="file16">github.com/zhekagigs/golang_todo/internal/workepool.go (0.0%)</option>
				
				<option value="file17">github.com/zhekagigs/golang_todo/logger/logger.go (100.0%)</option>
				
				<option value="file18">github.com/zhekagigs/golang_todo/middleware/middleware.go (50.0%)</option>
				
				<option value="file19">github.com/zhekagigs/golang_todo/repository/bucket.go (57.1%)</option>
				
				<option value="file20">github.com/zhekagigs/golang_todo/users/users.go (93.3%)</option>
				
				<option value="file21">github.com/zhekagigs/golang_todo/view/view.go (94.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package analytics

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"
)

func driveCoordinator(wg *sync.WaitGroup) <span class="cov0" title="0">{
        filesPaths, err := getJSONFiles("resources/")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">coord := MakeCoordinator(filesPaths, 5)
        for coord.Done() == false </span><span class="cov0" title="0">{
                time.Sleep(time.Second)
        }</span>
        <span class="cov0" title="0">if coord.Done() </span><span class="cov0" title="0">{
                fmt.Println("coordinator done")
        }</span>

        <span class="cov0" title="0">time.Sleep(time.Second)
        wg.Done()</span>
}

func driveWorkers(wg *sync.WaitGroup) <span class="cov0" title="0">{

        mapf := WcMap
        reducef := WcReduce

        Worker(mapf, reducef)
        wg.Done()
}</span>

func getJSONFiles(dir string) ([]string, error) <span class="cov0" title="0">{
        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading directory %s: %w", dir, err)
        }</span>

        <span class="cov0" title="0">var jsonFiles []string
        for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() &amp;&amp; strings.HasSuffix(entry.Name(), ".json") </span><span class="cov0" title="0">{
                        jsonFiles = append(jsonFiles, filepath.Join(dir, entry.Name()))
                }</span>
        }

        <span class="cov0" title="0">return jsonFiles, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package analytics

import (
        "fmt"
        "log"
        "net"
        "net/http"
        "net/rpc"
        "os"
)

/*
The workers will talk to the coordinator via RPC.
Each worker process will ask the coordinator for a task,
read the task's input from one or more files, execute the task,
and write the task's output to one or more files.
The coordinator should notice
if a worker hasn't completed its task in a reasonable amount of time
(for this lab, use ten seconds),
and give the same task to a different worker.
*/

type Coordinator struct {
        // Your definitions here.
        Tasks          []Task
        NumReduce      int
        MapTaskCode    int
        ReduceTaskCode int
}

// Your code here -- RPC handlers for the worker to call.

func (c *Coordinator) GiveMeAMapTask(request *TaskRequest, reply *TaskReply) error <span class="cov0" title="0">{
        log.Println("Coordinator::Map requested")

        for _, task := range c.Tasks </span><span class="cov0" title="0">{
                if !task.isMapped </span><span class="cov0" title="0">{
                        reply.Filename = task.Filename
                        reply.NumReducers = c.NumReduce
                        reply.TaskNumber = task.TaskNum
                        task.State = InProgress
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (c *Coordinator) TaskDone(request *TaskRequest, reply *TaskReply) error <span class="cov0" title="0">{
        log.Println("Coordinator::TaskDone requested")
        log.Println("Coordinator::received", request)

        for _, task := range c.Tasks </span><span class="cov0" title="0">{
                if task.TaskNum == request.TaskNumber </span><span class="cov0" title="0">{
                        task.State = request.State
                        if request.State == Completed &amp;&amp; request.TaskType == MapTask </span><span class="cov0" title="0">{
                                task.isMapped = true

                        }</span>
                        <span class="cov0" title="0">log.Println("Coordinator::updated task state", task.Filename, task.State)</span>
                }

                // if !task.isMapped {
                //         reply.Filename = task.Filename
                //         reply.NumReducers = c.NumReduce
                //         reply.TaskNumber = task.TaskNum
                //         task.State = InProgress
                // }
        }
        <span class="cov0" title="0">return nil</span>
}

// If no re- sponse is received from a worker in a certain amount of time, the master marks the worker as failed. Any map tasks completed by the worker are reset back to their ini- tial idle state, and therefore become eligible for schedul- ing on other workers. Similarly, any map task or reduce task in progress on a failed worker is also reset to idle and becomes eligible for rescheduling.
func (c *Coordinator) PingWorker() error <span class="cov0" title="0">{
        return nil
}</span>

func (c *Coordinator) giveMeAReduceTask(request *TaskRequest, reply *TaskReply) error <span class="cov0" title="0">{
        fmt.Println("Coordinator::Reduce requested")
        for _, task := range c.Tasks </span><span class="cov0" title="0">{
                if !task.isReduced </span><span class="cov0" title="0">{
                        reply.Filename = task.Filename
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// an example RPC handler.
// the RPC argument and reply types are defined in rpc.go.
func (c *Coordinator) Example(args *ExampleArgs, reply *ExampleReply) error <span class="cov0" title="0">{
        fmt.Println("Coordinator::Example hande")
        reply.Y = args.X + 11
        reply.World = " It's world, my man "
        return nil
}</span>

// start a thread that listens for RPCs from worker.go
func (c *Coordinator) server() <span class="cov0" title="0">{
        log.Println("server:: start serving")
        rpc.Register(c)
        rpc.HandleHTTP()
        //l, e := net.Listen("tcp", ":1234")
        sockname := coordinatorSock()
        os.Remove(sockname)
        l, e := net.Listen("unix", sockname)
        if e != nil </span><span class="cov0" title="0">{
                log.Fatal("listen error:", e)
        }</span>
        <span class="cov0" title="0">log.Println("Coordinator::Server listens on sockname")
        go http.Serve(l, nil)</span>
}

// main/mrcoordinator.go calls Done() periodically to find out
// if the entire job has finished.
func (c *Coordinator) Done() bool <span class="cov0" title="0">{
        result := true
        for _, task := range c.Tasks </span><span class="cov0" title="0">{
                if !task.isMapped || !task.isReduced </span><span class="cov0" title="0">{
                        result = false
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// create a Coordinator.
// main/mrcoordinator.go calls this function.
// nReduce is the number of reduce tasks to use.
func MakeCoordinator(files []string, nReduce int) *Coordinator <span class="cov0" title="0">{
        var tasks []Task
        for i, filename := range files </span><span class="cov0" title="0">{
                tasks = append(tasks, Task{filename, i, false, false, MapTask})
        }</span>
        <span class="cov0" title="0">c := Coordinator{
                Tasks:          tasks,
                NumReduce:      nReduce,
                MapTaskCode:    0,
                ReduceTaskCode: 0,
        }

        log.Println("Coordinator:: files to work", tasks)
        log.Println("Coordinator:: new coordinator made v.01")

        c.server()
        return &amp;c</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package analytics

//
// RPC definitions.
//
// remember to capitalize all names.
//

import (
        "fmt"
        "os"
        "strconv"
)

//
// example to show how to declare the arguments
// and reply for an RPC.
//

type MessageType int32

const (
        Idle       MessageType = 0
        InProgress MessageType = 1
        Completed  MessageType = 2
        ReduceTask MessageType = 3
        MapTask    MessageType = 4
)

func messageTypeString(t MessageType) string <span class="cov0" title="0">{
        switch t </span>{
        case Idle:<span class="cov0" title="0">
                return "Idle"</span>
        case InProgress:<span class="cov0" title="0">
                return "In Progress"</span>
        case Completed:<span class="cov0" title="0">
                return "Completed"</span>
        case ReduceTask:<span class="cov0" title="0">
                return "Reduce"</span>
        case MapTask:<span class="cov0" title="0">
                return "Map"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Unknown MessageType: %d", t)</span>
        }
}

type ExampleArgs struct {
        X     int
        Hello string
}

type ExampleReply struct {
        Y     int
        World string
}

type TaskRequest struct {
        State      MessageType
        FileNames  []string
        TaskNumber int
        TaskType   MessageType
}

type TaskReply struct {
        Filename    string
        TaskNumber  int
        NumReducers int
        TaskType    MessageType
        TaskState   MessageType
}

func (t TaskReply) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Filename: %s, Task Number: %d, Num Reducers: %d, Task Type: %s",
                t.Filename, t.TaskNumber, t.NumReducers, messageTypeString(t.TaskType))
}</span>

type Task struct {
        Filename  string
        TaskNum   int
        isMapped  bool
        isReduced bool
        State     MessageType
}

// Add your RPC definitions here.

// Cook up a unique-ish UNIX-domain socket name
// in /var/tmp, for the coordinator.
// Can't use the current directory since
// Athena AFS doesn't support UNIX-domain sockets.
func coordinatorSock() string <span class="cov0" title="0">{
        s := "/var/tmp/5840-mr-"
        s += strconv.Itoa(os.Getuid())
        return s
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package analytics

import (
        "strconv"
        "strings"
        "unicode"
)

// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
func WcMap(filename string, contents string) []KeyValue <span class="cov8" title="1">{
        // function to detect word separators.
        ff := func(r rune) bool </span><span class="cov8" title="1">{ return !unicode.IsLetter(r) }</span>

        // split contents into an array of words.
        <span class="cov8" title="1">words := strings.FieldsFunc(contents, ff)

        kva := []KeyValue{}
        for _, word := range words </span><span class="cov8" title="1">{
                kv := KeyValue{Key: word, Value: "1"}
                kva = append(kva, kv)
        }</span>
        <span class="cov8" title="1">return kva</span>
}

// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
func WcReduce(key string, values []string) string <span class="cov8" title="1">{
        // return the number of occurrences of this word.
        return strconv.Itoa(len(values))
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package analytics

import (
        "bufio"
        "fmt"
        "hash/fnv"
        "io"
        "log"
        "net/rpc"
        "os"
        "sort"
        "strconv"
        "strings"
)

// Map functions return a slice of KeyValue.
type KeyValue struct {
        Key   string
        Value string
}

// for sorting by key.
type ByKey []KeyValue

// for sorting by key.
func (a ByKey) Len() int           <span class="cov0" title="0">{ return len(a) }</span>
func (a ByKey) Swap(i, j int)      <span class="cov0" title="0">{ a[i], a[j] = a[j], a[i] }</span>
func (a ByKey) Less(i, j int) bool <span class="cov0" title="0">{ return a[i].Key &lt; a[j].Key }</span>

func ScanFile(f *os.File) (map[string]string, error) <span class="cov0" title="0">{
        var (
                kmap map[string]string
                err  error
        )
        // Read the entire file into a byte slice
        b, err := io.ReadAll(f)
        if err != nil </span><span class="cov0" title="0">{
                return kmap, err
        }</span>
        // Convert the byte slice to a string
        <span class="cov0" title="0">str := string(b[:])
        // Split the string into lines
        lines := strings.Split(str, "\n")
        // Iterate over the lines and split them into key-value pairs
        for _, line := range lines </span><span class="cov0" title="0">{
                parts := strings.SplitN(line, ":", 2)
                key := parts[0]
                value := parts[1]
                kmap[key] = value
        }</span>
        <span class="cov0" title="0">return kmap, nil</span>
}

// use ihash(key) % NReduce to choose the reduce
// task number for each KeyValue emitted by Map.
func ihash(key string) int <span class="cov0" title="0">{
        h := fnv.New32a()
        h.Write([]byte(key))
        return int(h.Sum32() &amp; 0x7fffffff)
}</span>

// main/mrworker.go calls this function.
// The map phase should divide the intermediate keys into buckets for nReduce reduce
// tasks, where nReduce is the number of reduce tasks -- the argument that
// main/mrcoordinator.go passes to MakeCoordinator(). Each mapper should create
// nReduce intermediate files for consumption by the reduce tasks.
// The worker implementation should put the output of the X'th reduce task in the file mr-out-X.
// A mr-out-X file should contain one line per Reduce function output. The line should be generated with the Go "%v %v" format, called with the key and value.
// When the job is completely finished, the worker processes should exit. A simple way to implement this is to use the return value from call(): if the worker fails to contact the coordinator, it can assume that the coordinator has exited because the job is done, so the worker can terminate too. Depending on your design, you might also find it helpful to have a "please exit" pseudo-task that the coordinator can give to workers.
func Worker(mapf func(string, string) []KeyValue, reducef func(string, []string) string) <span class="cov0" title="0">{

        log.Println("Worker:: worker started")
        for </span><span class="cov0" title="0">{
                reply := CallCoordinatorForTask("GiveMeAMapTask")
                log.Println("task received", MessageType(reply.TaskType))
                if reply.TaskType == MapTask || reply.TaskState == Idle </span><span class="cov0" title="0">{
                        tmpFileNames := doMap(mapf, reply)
                        CallMapTaskDone(tmpFileNames, reply.TaskNumber)
                }</span>
                <span class="cov0" title="0">if reply.TaskType == ReduceTask </span><span class="cov0" title="0">{
                        doReduce(reply, reply.Filename, reducef)
                }</span> else<span class="cov0" title="0"> {
                        log.Panicf("unknown task type, %v", reply.TaskType)
                }</span>
        }
}

func CallMapTaskDone(tmpFileNames []string, tasknumber int) TaskReply <span class="cov0" title="0">{
        log.Println("Worker::callMapTaskDone initialized")
        args := TaskRequest{Completed, tmpFileNames, tasknumber, MapTask}
        reply := TaskReply{}
        handlerName := "TaskDone"
        ok := call("Coordinator."+handlerName, &amp;args, &amp;reply)
        if ok </span><span class="cov0" title="0">{
                log.Printf("Worker::coordinator replied with %s\n", reply)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("MyCall failed!")
        }</span>

        <span class="cov0" title="0">return reply</span>
}

func doReduce(replied TaskReply, intermediate string, reducef func(string, []string) string) <span class="cov0" title="0">{
        oname := "mr-out-" + strconv.Itoa(replied.TaskNumber)
        ofile, _ := os.Create(oname)
        produceReducedOutput(intermediate, reducef, ofile)
        log.Println("Worker::finished printing out file " + oname)
        ofile.Close()
}</span>

func doMap(mapf func(string, string) []KeyValue, replied TaskReply) []string <span class="cov0" title="0">{
        log.Printf("Worker::doMap\n")
        intermediate := collectIntermediate(mapf, replied.Filename, replied.NumReducers)
        // debug := 0
        // for k, v := range intermediate {
        //         fmt.Println(k, v)
        //         if debug &gt; 10 {
        //                 break
        //         }
        //         debug++
        // }
        var interNames []string
        interName := "map-inter-"

        for key, interGroupings := range intermediate </span><span class="cov0" title="0">{
                sort.Sort(ByKey(interGroupings))
                tmpIntername := interName + strconv.Itoa(key) + "-" + replied.Filename
                interFile, _ := os.Create(tmpIntername)
                for _, kvpair := range interGroupings </span><span class="cov0" title="0">{
                        fmt.Fprintf(interFile, "%v %v\n", kvpair.Key, kvpair.Value)
                }</span>
                <span class="cov0" title="0">log.Println("Worker::created temp file ", interName+strconv.Itoa(key))
                interFile.Close()
                interNames = append(interNames, tmpIntername)</span>
        }
        <span class="cov0" title="0">log.Println("Worker::finished printing intermeditea file " + interName)
        return interNames</span>
}

func collectIntermediate(mapf func(string, string) []KeyValue, filename string, nReduce int) map[int][]KeyValue <span class="cov0" title="0">{
        log.Printf("Worker::doMap\n")

        partitions := make(map[int][]KeyValue)

        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("cannot open %v", filename)
        }</span>
        <span class="cov0" title="0">content, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("cannot read %v", filename)
        }</span>
        <span class="cov0" title="0">file.Close()
        keyValuePairs := mapf(filename, string(content))
        for _, kv := range keyValuePairs </span><span class="cov0" title="0">{
                partitionKey := ihash(kv.Key) % nReduce

                if _, ok := partitions[partitionKey]; !ok </span><span class="cov0" title="0">{
                        partitions[partitionKey] = []KeyValue{kv}
                }</span> else<span class="cov0" title="0"> {
                        partitions[partitionKey] = append(partitions[partitionKey], kv)
                }</span>
                <span class="cov0" title="0">if (len(partitions)) &gt; nReduce </span><span class="cov0" title="0">{
                        panic("Worker:: partition unexpected")</span>
                }
        }

        <span class="cov0" title="0">return partitions</span>
}

func produceReducedOutput(intermediateFile string, reducef func(string, []string) string, ofile *os.File) <span class="cov0" title="0">{
        i := 0
        f, err := os.Open(intermediateFile)
        if err != nil </span><span class="cov0" title="0">{
                panic("Error reduce task reading inter file")</span>
        }
        <span class="cov0" title="0">defer f.Close()

        // // Create a scanner to scan the file
        // scanner := Scanner{
        //         F:        f,
        //         Buffer:   make([]byte, 1024),
        //         Capacity: 1024,
        // }

        scanner := bufio.NewScanner(f)

        var kvCollector []KeyValue

        // Iterate over each line in the file
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                // Check for errors while scanning
                if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error reading file:", err)
                }</span>
                // Trim the newline character from the end of the line
                <span class="cov0" title="0">line = strings.TrimRight(line, "\r\n")
                // Parse the line into a KeyValue struct
                var kv KeyValue

                _, err = fmt.Sscanf(line, "%s %s", &amp;kv.Key, &amp;kv.Value)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        continue</span>
                }
                <span class="cov0" title="0">kvCollector = append(kvCollector, kv)</span>
                // Do something with the KeyValue struct
        }

        <span class="cov0" title="0">for i &lt; len(kvCollector) </span><span class="cov0" title="0">{
                j := i + 1
                for j &lt; len(kvCollector) &amp;&amp; kvCollector[j].Key == kvCollector[i].Key </span><span class="cov0" title="0">{
                        j++
                }</span>
                <span class="cov0" title="0">values := []string{}
                for k := i; k &lt; j; k++ </span><span class="cov0" title="0">{
                        values = append(values, kvCollector[k].Value)
                }</span>
                <span class="cov0" title="0">output := reducef(kvCollector[i].Key, values)

                fmt.Fprintf(ofile, "%v %v\n", kvCollector[i].Key, output)

                i = j</span>
        }
}

func CallCoordinatorForTask(handlerName string) TaskReply <span class="cov0" title="0">{
        log.Println("Worker::CallForMapTask")
        args := TaskRequest{}
        reply := TaskReply{}
        ok := call("Coordinator."+handlerName, &amp;args, &amp;reply)
        if ok </span><span class="cov0" title="0">{
                log.Printf("Worker::coordinator replied with %s\n", reply)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("MyCall failed!")
        }</span>
        <span class="cov0" title="0">return reply</span>
}

// example function to show how to make an RPC call to the coordinator.
//
// the RPC argument and reply types are defined in rpc.go.
func CallExample() <span class="cov0" title="0">{
        log.Println()
        // declare an argument structure.
        args := ExampleArgs{}

        // fill in the argument(s).
        args.X = 99
        args.Hello = "Hello"

        // declare a reply structure.
        reply := ExampleReply{}

        // send the RPC request, wait for the reply.
        // the "Coordinator.Example" tells the
        // receiving server that we'd like to call
        // the Example() method of struct Coordinator.
        ok := call("Coordinator.Example", &amp;args, &amp;reply)
        if ok </span><span class="cov0" title="0">{
                // reply.Y should be 100.
                fmt.Printf("reply.Y %v\n", reply.Y)
                fmt.Printf("coordinator replyed with %s\n", reply.World)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Example call failed!\n")
        }</span>

}

// send an RPC request to the coordinator, wait for the response.
// usually returns true.
// returns false if something goes wrong.
func call(rpcname string, args interface{}, reply interface{}) bool <span class="cov0" title="0">{
        // c, err := rpc.DialHTTP("tcp", "127.0.0.1"+":1234")
        sockname := coordinatorSock()
        c, err := rpc.DialHTTP("unix", sockname)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("dialing:", err)
        }</span>
        <span class="cov0" title="0">defer c.Close()

        err = c.Call(rpcname, args, reply)
        if err == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">fmt.Println(err)
        return false</span>
}

func SplitSlice(array []int, numberOfChunks int) [][]int <span class="cov0" title="0">{
        if len(array) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if numberOfChunks &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if numberOfChunks == 1 </span><span class="cov0" title="0">{
                return [][]int{array}
        }</span>
        <span class="cov0" title="0">result := make([][]int, numberOfChunks)
        // we have more splits than elements in the input array.
        if numberOfChunks &gt; len(array) </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(array); i++ </span><span class="cov0" title="0">{
                        result[i] = []int{array[i]}
                }</span>
                <span class="cov0" title="0">return result</span>
        }
        <span class="cov0" title="0">for i := 0; i &lt; numberOfChunks; i++ </span><span class="cov0" title="0">{
                min := (i * len(array) / numberOfChunks)
                max := ((i + 1) * len(array)) / numberOfChunks
                result[i] = array[min:max]
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package cli

import (
        "bufio"
        "errors"
        "flag"
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        in "github.com/zhekagigs/golang_todo/internal"
)

type command string

const (
        READ   command = "read"
        FIND   command = "find"
        SEARCH command = "search"
        CREATE command = "create"
        UPDATE command = "update"
        DELETE command = "delete"
        EXIT   command = "exit"
)

const (
        ExitCodeSuccess = 0
        ExitCodeError   = 1
)

type CLIApp interface {
        AppStarter(newTaskHolder func(diskPath string) *in.TaskHolder) (*in.TaskHolder, bool, int, bool)
        RunTaskManagmentCLI(taskHolder *in.TaskHolder) int
}

type RealCLIApp struct {
}

func (cli *RealCLIApp) RunTaskManagmentCLI(taskHolder *in.TaskHolder) int <span class="cov8" title="1">{
        reader := bufio.NewReader(os.Stdin)
        for </span><span class="cov8" title="1">{
                displayCommands()
                cmd, taskId, word, err := parseCommand(reader)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        continue</span>
                }

                <span class="cov8" title="1">if exitCode := executeCommand(cmd, taskId, word, taskHolder, reader); exitCode != -1 </span><span class="cov8" title="1">{
                        return exitCode
                }</span>
        }
}

func (cli *RealCLIApp) AppStarter(newTaskHolder func(diskPath string) *in.TaskHolder) (*in.TaskHolder, bool, int, bool) <span class="cov8" title="1">{
        fileName, savedTasks, isHelp, isExit, exitCode, isWeb := ParseUserArg()
        if isHelp </span><span class="cov8" title="1">{
                return nil, isExit, exitCode, isWeb
        }</span>
        <span class="cov8" title="1">var taskHolder *in.TaskHolder
        if !isWeb </span><span class="cov8" title="1">{
                var err error
                taskHolder, err = PopulateTaskHolder(fileName, savedTasks, newTaskHolder)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error populating task holder: %v\n", err)
                        return nil, true, ExitCodeError, isWeb
                }</span>
        } else<span class="cov0" title="0"> {
                taskHolder = newTaskHolder(fileName)
        }</span>
        <span class="cov8" title="1">PrintCLITitle(taskHolder.Tasks)

        return taskHolder, false, ExitCodeSuccess, isWeb</span>
}

func PrintCLITitle(savedTasks []in.Task) <span class="cov8" title="1">{
        fmt.Println(in.BeerAscii())
        fmt.Printf("\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Microbrewery Tasks Application&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n\n")
        in.PrintTasks(os.Stdout, savedTasks...)
}</span>

func PopulateTaskHolder(fileName string, savedTasks []in.Task, newTaskHolder func(diskPath string) *in.TaskHolder) (*in.TaskHolder, error) <span class="cov8" title="1">{
        if fileName == "" </span><span class="cov0" title="0">{
                fileName = "resources/tasks.json"
        }</span>
        <span class="cov8" title="1">taskHolder := newTaskHolder(fileName)
        for _, task := range savedTasks </span><span class="cov8" title="1">{
                taskHolder.Add(task)
        }</span>
        <span class="cov8" title="1">return taskHolder, nil</span>
}

func ParseUserArg() (fileName string, savedTasks []in.Task, isHelp bool, isExit bool, exitCode int, isWebFlag bool) <span class="cov8" title="1">{
        helpFlag := flag.Bool("h", false, "Help is here")
        webFlag := flag.Bool("web", false, "Avoids using CLI")
        flag.Usage = PrintHelp

        flag.Parse()

        if *helpFlag </span><span class="cov8" title="1">{
                flag.Usage()
                return "", nil, *helpFlag, true, ExitCodeSuccess, *webFlag
        }</span>

        <span class="cov8" title="1">if flag.NArg() &lt; 1 </span><span class="cov8" title="1">{
                fmt.Println("Error: JSON file path is required")
                flag.Usage()
                return "", nil, true, true, ExitCodeError, *webFlag
        }</span>

        <span class="cov8" title="1">fileName = flag.Arg(0)
        savedTasks, err := in.ReadTasksFromJSON(fileName)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, os.ErrNotExist):<span class="cov0" title="0">
                        fmt.Println("Error: Wrong file path")</span>
                default:<span class="cov8" title="1">
                        fmt.Printf("Error while reading json file: %v\n", err)</span>
                }
                <span class="cov8" title="1">flag.Usage()
                return "", nil, true, true, ExitCodeError, *webFlag</span>
        }
        <span class="cov8" title="1">return fileName, savedTasks, false, false, ExitCodeSuccess, *webFlag</span>
}

func PrintHelp() <span class="cov8" title="1">{
        fmt.Println("Usage: microbrewery-tasks [options] &lt;json-file-path&gt;")
        fmt.Println("\nOptions:")
        flag.PrintDefaults()
        fmt.Println("\nDescription:")
        fmt.Println("  This CLI application reads a JSON file containing microbrewery tasks and displays them.")
        fmt.Println("  Provide the path to the JSON file as an argument.")
}</span>

func displayCommands() <span class="cov8" title="1">{
        fmt.Println("\nAvailable Commands: read, create, update, delete, exit, search, find")
        fmt.Println("Enter Command: ")
}</span>

func parseCommand(reader *bufio.Reader) (command, int, string, error) <span class="cov8" title="1">{
        cmdString, _ := reader.ReadString('\n')
        parts := strings.Fields(cmdString)
        if len(parts) == 0 </span><span class="cov8" title="1">{
                return "", -1, "", fmt.Errorf("Please enter a command.")
        }</span>

        <span class="cov8" title="1">cmd := command(strings.TrimSpace(strings.ToLower(parts[0])))

        var taskId int
        var word string = ""
        var err error

        if len(parts) &gt; 1 &amp;&amp; (cmd == UPDATE || cmd == DELETE || cmd == FIND) </span><span class="cov8" title="1">{
                taskId, err = strconv.Atoi(parts[1])
                if err != nil </span><span class="cov8" title="1">{
                        return "", -1, "", fmt.Errorf("Invalid task ID. Please enter a number.")
                }</span>
                <span class="cov8" title="1">return cmd, taskId, word, nil</span>
        } else<span class="cov8" title="1"> if len(parts) &gt; 1 &amp;&amp; (cmd == SEARCH) </span><span class="cov0" title="0">{
                word = parts[1]
        }</span>

        <span class="cov8" title="1">return cmd, taskId, word, nil</span>
}

func executeCommand(cmd command, taskId int, word string, taskHolder *in.TaskHolder, reader *bufio.Reader) int <span class="cov8" title="1">{
        var err error
        switch cmd </span>{
        case READ:<span class="cov8" title="1">
                err = readTasks(taskHolder)</span>
        case FIND:<span class="cov0" title="0">
                err = findTaskById(taskHolder, taskId)</span>
        case SEARCH:<span class="cov0" title="0">
                err = searchTaskByWord(taskHolder, word)</span>
        case CREATE:<span class="cov8" title="1">
                err = createTask(taskHolder, reader)</span>
        case UPDATE:<span class="cov8" title="1">
                err = updateTask(taskHolder, taskId, reader)</span>
        case DELETE:<span class="cov8" title="1">
                err = deleteTask(taskHolder, taskId)</span>
        case EXIT:<span class="cov8" title="1">
                return exitApp(taskHolder)</span>
        default:<span class="cov8" title="1">
                fmt.Println("Invalid command. Please try again.")</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                fmt.Println("Failed operation with error: ", err)
        }</span>

        <span class="cov8" title="1">return -1</span> // Continue the loop
}

func searchTaskByWord(taskHolder *in.TaskHolder, word string) error <span class="cov0" title="0">{
        tasks, err := taskHolder.SearchTaskByWord(word)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">in.PrintTasks(os.Stdout, tasks...)
        fmt.Printf("\nFound %d tasks\n", len(tasks))
        return nil</span>
}

func findTaskById(taskHolder *in.TaskHolder, taskId int) error <span class="cov0" title="0">{

        task, err := taskHolder.FindTaskById(taskId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Println(task.String() + "\n")
        return nil</span>
}

func exitApp(taskHolder *in.TaskHolder) int <span class="cov8" title="1">{
        fmt.Println("Thank you for using the Task Management CLI. Tasks are saved to ", taskHolder.DiskPath, " GoodBye!")
        err := in.WriteToJson(taskHolder.DiskPath, taskHolder.Tasks...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return 0</span>
}

func deleteTask(taskHolder *in.TaskHolder, taskId int) error <span class="cov8" title="1">{
        err := taskHolder.DeleteTask(taskId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return err</span>
}

func updateTask(taskHolder *in.TaskHolder, taskId int, reader *bufio.Reader) error <span class="cov8" title="1">{
        fmt.Println("Updating task. Press Enter to skip a field if you don't want to update it.")

        // Update task message
        fmt.Print("Enter new task description (or press Enter to skip): ")
        msg, _ := reader.ReadString('\n')
        msg = strings.TrimSpace(msg)

        // Update task status
        var donePtr *bool
        fmt.Print("Is task doen(true/false)? (or press Enter to skip): ")
        doneStr, _ := reader.ReadString('\n')
        doneStr = strings.TrimSpace(doneStr)
        if len(doneStr) == 4 || len(doneStr) == 5 </span><span class="cov0" title="0">{
                if parsedDone, err := strconv.ParseBool(doneStr); err == nil </span><span class="cov0" title="0">{
                        donePtr = &amp;parsedDone
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        // Update task category
        <span class="cov8" title="1">var category in.TaskCategory
        var categoryPtr *in.TaskCategory
        fmt.Print("Update task category? (y/n): ")
        // if strings.ToLower(strings.TrimSpace(updateCategory)) == "y" {
        fmt.Println("Available categories:")
        fmt.Println("0: Brewing")
        fmt.Println("1: Marketing")
        fmt.Println("2: Logistics")
        fmt.Println("3: Quality")
        fmt.Print("Enter new category (0-3)(or press Enter to skip): ")
        categoryStr, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(categoryStr) &gt; 0 </span><span class="cov8" title="1">{
                if parsedCategory, err := strconv.Atoi(strings.TrimSpace(categoryStr)); err == nil &amp;&amp; parsedCategory &gt;= 0 &amp;&amp; parsedCategory &lt;= 3 </span><span class="cov0" title="0">{
                        category = in.TaskCategory(parsedCategory)
                        categoryPtr = &amp;category
                }</span> else<span class="cov8" title="1"> {
                        return err
                }</span>
        }

        // Update planned time
        <span class="cov0" title="0">var plannedAtPtr *time.Time
        fmt.Print("Update planned time? (y/n): ")
        updatePlannedTime, _ := reader.ReadString('\n')
        if strings.ToLower(strings.TrimSpace(updatePlannedTime)) == "y" </span><span class="cov0" title="0">{
                fmt.Print("Enter new planned time (YYYY-MM-DD HH:MM): ")
                timeStr, _ := reader.ReadString('\n')
                fmt.Println("timeStr", timeStr)
                if parsedTime, err := time.Parse(in.TASK_TIME_FORMAT, strings.TrimSpace(timeStr)); err == nil </span><span class="cov0" title="0">{
                        plannedAtPtr = &amp;parsedTime
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }
        <span class="cov0" title="0">customTime, err := in.NewCustomTime(plannedAtPtr)
        if err != nil </span><span class="cov0" title="0">{
                if err != in.ErrTimeNilPointer </span><span class="cov0" title="0">{
                        fmt.Printf("Error updating task: %v\n", err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">update := &amp;in.TaskOptional{
                Done:      donePtr,
                Msg:       in.StringPtr(msg),
                Category:  categoryPtr,
                PlannedAt: customTime,
        }

        err = taskHolder.PartialUpdateTask(taskId, update)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error updating task: %v\n", err)
                return err
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Task updated successfully.")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func createTask(taskHolder *in.TaskHolder, reader *bufio.Reader) error <span class="cov8" title="1">{

        fmt.Println("Enter new task on one line in a format 'task, category, planned to finish date'")
        fmt.Println("Available categories:")
        fmt.Println("0: Brewing")
        fmt.Println("1: Marketing")
        fmt.Println("2: Logistics")
        fmt.Println("3: Quality")
        fmt.Println("Format time (YYYY-MM-DD HH:MM)")
        fmt.Println("Example: `Finish brewing IPA, 0, 2024-08-29 14:27`")

        line, err := reader.ReadString('\n') //TODO unignore errors
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">lines := strings.Split(line, ",")

        taskValue := lines[0]
        categoryNum, err := strconv.Atoi(strings.TrimSpace(lines[1]))
        // fmt.Println(categoryNum)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">plannedAt := lines[2]
        var plannedParsedAt time.Time
        parsedTime, err := time.Parse(in.TASK_TIME_FORMAT, strings.TrimSpace(plannedAt))
        if err == nil </span><span class="cov8" title="1">{
                plannedParsedAt = parsedTime
        }</span>
        <span class="cov8" title="1">updt := in.TaskOptional{
                Done:      nil,
                Msg:       in.StringPtr(taskValue),
                Category:  in.CategoryPtr(in.TaskCategory(categoryNum)),
                PlannedAt: in.TimePtr(plannedParsedAt),
        }

        taskHolder.CreateTask(updt)
        return nil</span>
}

func readTasks(taskHolder *in.TaskHolder) error <span class="cov8" title="1">{
        all_tasks := taskHolder.Read()
        if len(all_tasks) == 0 </span><span class="cov8" title="1">{
                fmt.Println("No tasks found.")
                return errors.New("No tasks found")
        }</span>

        <span class="cov8" title="1">fmt.Printf("\nList of tasks:\n\n")
        in.PrintTasks(os.Stdout, all_tasks...)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "net/http"
        _ "net/http/pprof"
        "os"
        "os/signal"
        "syscall"

        "github.com/zhekagigs/golang_todo/cli"
        "github.com/zhekagigs/golang_todo/controller"
        "github.com/zhekagigs/golang_todo/internal"
        "github.com/zhekagigs/golang_todo/logger"
        mid "github.com/zhekagigs/golang_todo/middleware"
        "github.com/zhekagigs/golang_todo/repository"
        "github.com/zhekagigs/golang_todo/users"
        "github.com/zhekagigs/golang_todo/view"
)

func main() <span class="cov0" title="0">{
        repo, err := repository.ConfigureRepo()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error.Printf("Failed to create repository: %v", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer repo.Close()

        // Load initial tasks from GCS
        taskHolder := loadTasks(repo)

        // Start the application if GCP
        os.Exit(RealMain(
                func(string) *internal.TaskHolder </span><span class="cov0" title="0">{ return taskHolder }</span>,
                &amp;controller.RealHTTPServer{},
                &amp;cli.RealCLIApp{},
        ))

        // Start app if local JSON storage
        // os.Exit(RealMain(internal.NewTaskHolder, &amp;controller.RealHTTPServer{}, &amp;cli.RealCLIApp{}))
}

func loadTasks(repo *repository.GCSRepository) *internal.TaskHolder <span class="cov0" title="0">{
        tasks, err := repo.LoadTasks()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error.Printf("Failed to load tasks: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">taskHolder := internal.NewTaskHolder("")
        for _, task := range tasks </span><span class="cov0" title="0">{
                taskHolder.Add(task)
        }</span>
        <span class="cov0" title="0">return taskHolder</span>
}

func RealMain(newTaskHolder func(diskPath string) *internal.TaskHolder, server controller.HTTPServer, cliApp cli.CLIApp) int <span class="cov8" title="1">{
        // Initialize with environment variables or defaults
        port := os.Getenv("PORT")
        if port == "" </span><span class="cov8" title="1">{
                port = "8080"
        }</span>

        <span class="cov8" title="1">usersFile := os.Getenv("USERS_FILE")
        if usersFile == "" </span><span class="cov8" title="1">{
                usersFile = "users.json"
        }</span>

        <span class="cov8" title="1">taskHolder, checkExit, exitCode, isWeb := cliApp.AppStarter(newTaskHolder)
        if checkExit </span><span class="cov0" title="0">{
                return exitCode
        }</span>

        <span class="cov8" title="1">renderer, err := view.NewRenderer()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error.Printf("error starting view renderer")
                return cli.ExitCodeError
        }</span>

        <span class="cov8" title="1">taskConcurrentService := internal.NewConcurrentTaskService(taskHolder)
        taskRenderHandler := controller.NewTaskRenderHandler(taskHolder, renderer)
        userStore, err := users.NewUserStore(usersFile)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error.Printf("error loading user store file")
                return cli.ExitCodeError
        }</span>

        <span class="cov8" title="1">api := controller.NewApiService(taskConcurrentService, userStore)
        authHandler := controller.NewAuthHandler(userStore)

        // Setup shutdown channel
        shutdownChan := make(chan struct{})
        errChan := make(chan error, 1)
        // Start HTTP server in goroutine
        go func() </span><span class="cov8" title="1">{
                if err := startHTTPServer(port, taskRenderHandler, server, api, authHandler); err != nil </span><span class="cov0" title="0">{
                        logger.Error.Printf("Failed to start server: %v", err)
                        errChan &lt;- err
                }</span>
        }()

        // Handle graceful shutdown
        <span class="cov8" title="1">go handleShutdown(shutdownChan)

        // Run service
        if isWeb </span><span class="cov0" title="0">{
                logger.Info.Println("web flag provide")
                select </span>{
                case err := &lt;-errChan:<span class="cov0" title="0">
                        logger.Error.Println(err)
                        return cli.ExitCodeError</span>
                case &lt;-shutdownChan:<span class="cov0" title="0">
                        return cli.ExitCodeSuccess</span>
                }
        } else<span class="cov8" title="1"> {
                logger.Info.Println("web flag not provided, cli and web app started")
                cliDoneChan := make(chan int)

                go func() </span><span class="cov8" title="1">{
                        returnCode := cliApp.RunTaskManagmentCLI(taskHolder)
                        cliDoneChan &lt;- returnCode
                }</span>()
                <span class="cov8" title="1">select </span>{
                case returnCode := &lt;-cliDoneChan:<span class="cov8" title="1">
                        close(shutdownChan)
                        return returnCode</span>
                case err := &lt;-errChan:<span class="cov0" title="0">
                        logger.Error.Println(err)
                        return cli.ExitCodeError</span>
                case &lt;-shutdownChan:<span class="cov0" title="0">
                        return cli.ExitCodeSuccess</span>
                }
        }
}

func startHTTPServer(port string, taskHandler *controller.TaskRenderHandler, server controller.HTTPServer, api *controller.ApiService, authHandler *controller.AuthHandler) error <span class="cov8" title="1">{
        router := http.NewServeMux()
        // api routes
        router.HandleFunc("GET /api/tasks", api.GetAllPosts)
        router.HandleFunc("GET /api/tasks/{id}", api.GetTaskById)
        router.HandleFunc("POST /api/tasks", mid.AuthMiddleware(api.CreateTask))
        router.HandleFunc("PUT /api/tasks/{id}", mid.AuthMiddleware(api.UpdateTask))
        router.HandleFunc("DELETE /api/tasks/{id}", mid.AuthMiddleware(api.DeleteTask))
        // auth routes
        router.HandleFunc("POST /login", authHandler.LoginHandler)
        router.HandleFunc("POST /logout", authHandler.LogoutHandler)
        // view routes
        router.HandleFunc("GET /tasks/create", mid.AuthMiddleware(taskHandler.HandleTaskCreate))
        router.HandleFunc("GET /tasks", taskHandler.HandleTaskListRead)
        router.HandleFunc("DELETE /tasks", mid.AuthMiddleware(taskHandler.HandleTaskDelete))
        router.HandleFunc("GET /tasks/update", mid.AuthMiddleware(taskHandler.HandleTaskUpdate))
        router.HandleFunc("POST /tasks/update", mid.AuthMiddleware(taskHandler.HandleTaskUpdate))
        router.HandleFunc("GET /", taskHandler.HandleTaskListRead)

        // Health check
        router.HandleFunc("GET /health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
        }</span>)

        <span class="cov8" title="1">loggingHandler := mid.LoggingMiddleware{Next: router}

        logger.Info.Printf("Starting server on :%s", port)
        return server.ListenAndServe(":"+port, loggingHandler)</span>
}

// gracefult shutdown handling
func handleShutdown(done chan struct{}) <span class="cov8" title="1">{
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)

        select </span>{
        case &lt;-sigChan:<span class="cov0" title="0">
                logger.Info.Println("Received shutdown signal")
                done &lt;- struct{}{}</span>
        case &lt;-done:<span class="cov8" title="1">
                logger.Info.Println("Server stopped via done channel")</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package controller

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"

        "github.com/zhekagigs/golang_todo/internal"
        "github.com/zhekagigs/golang_todo/logger"
        "github.com/zhekagigs/golang_todo/middleware"
        "github.com/zhekagigs/golang_todo/users"
)

var (
        ErrWrongRequest = errors.New("wrong request")
        ErrInternal     = errors.New("server error")
)

type ApiService struct {
        // taskService  *internal.TaskHolder
        taskService *internal.ConcurrentTaskService
        userStore   *users.UserStore
}

func (apiHandler ApiService) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        logger.Info.Printf("ServeHttp Received %s request for %s from %s", r.Method, r.URL.Path, r.RemoteAddr)
}</span>

func NewApiService(internal *internal.ConcurrentTaskService, userStore *users.UserStore) *ApiService <span class="cov8" title="1">{
        return &amp;ApiService{
                taskService: internal,
                userStore:   userStore,
        }
}</span>

func (api *ApiService) GetAllPosts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        posts := api.taskService.Read()

        postsJson, err := json.Marshal(posts)
        if isJsonErr(err, w) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        w.Write(postsJson)</span>
}

func (api *ApiService) GetTaskById(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        taskId, err := getTaskIdFromPath(r)
        if handleError(w, err, http.StatusInternalServerError, "api: error processing taskId") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">task, err := api.taskService.FindTaskById(taskId)
        if handleError(w, err, http.StatusInternalServerError, "api: task not found") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">taskJson, err := json.Marshal(task)
        if isJsonErr(err, w) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader((http.StatusOK))
        w.Write(taskJson)</span>
}

func (api *ApiService) CreateTask(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        userId, ok := middleware.UserFromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                logger.Error.Println("user not found by id")
                http.Error(w, "Task not found", http.StatusNotFound)

        }</span>
        <span class="cov8" title="1">user, ok := api.userStore.GetUserById(userId)
        if !ok </span><span class="cov0" title="0">{
                logger.Error.Println("user not found by id")
                http.Error(w, "Task not found", http.StatusNotFound)

        }</span>
        <span class="cov8" title="1">var taskRequest *internal.TaskOptional
        err := json.NewDecoder(r.Body).Decode(&amp;taskRequest)

        taskRequest.CreatedBy = &amp;user
        if handleError(w, err, http.StatusBadRequest, "error decoding request body") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">task := api.taskService.CreateTask(*taskRequest)
        taskAsJson, err := json.Marshal(task)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrInternal.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-type", "application/json")
        w.WriteHeader(http.StatusCreated)
        w.Write(taskAsJson)</span>
}

func (api *ApiService) UpdateTask(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var taskRequest *internal.TaskOptional
        err := json.NewDecoder(r.Body).Decode(&amp;taskRequest)
        if handleError(w, err, http.StatusBadRequest, "error decoding request body") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">taskId, err := getTaskIdFromPath(r)
        if handleError(w, err, http.StatusBadRequest, "error parsing taskId") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">task := api.taskService.PartialUpdateTask(taskId, taskRequest)
        taskAsJson, err := json.Marshal(task)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrInternal.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-type", "application/json")
        w.WriteHeader(http.StatusCreated)
        w.Write(taskAsJson)</span>
}

func (api *ApiService) DeleteTask(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        taskId, err := getTaskIdFromPath(r)
        if handleError(w, err, http.StatusBadRequest, "api: error processing taskId") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">err = api.taskService.DeleteTask(taskId)
        if handleError(w, err, http.StatusBadRequest, "api: task not foound") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">w.WriteHeader((http.StatusOK))</span>
}

func isJsonErr(err error, w http.ResponseWriter) bool <span class="cov0" title="0">{
        return handleError(w, err, http.StatusBadRequest, "api: json serialization error")
}</span>

func getTaskIdFromPath(r *http.Request) (int, error) <span class="cov0" title="0">{
        taskIdStr := r.PathValue("id")
        if taskIdStr == "" </span><span class="cov0" title="0">{
                return -1, errors.New("task id is empty")
        }</span>
        <span class="cov0" title="0">return strconv.Atoi(taskIdStr)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package controller

import (
        "encoding/json"
        "net/http"

        "github.com/zhekagigs/golang_todo/logger"
        "github.com/zhekagigs/golang_todo/users"
)

type AuthHandler struct {
        UserStore *users.UserStore
}

func NewAuthHandler(userStore *users.UserStore) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{UserStore: userStore}
}</span>

type loginRequest struct {
        UserName string `json:"userName"`
}

func (ah *AuthHandler) LoginHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var loginRequest *loginRequest

        err := json.NewDecoder(r.Body).Decode(&amp;loginRequest)
        if handleError(w, err, http.StatusBadRequest, "error decoding request body") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">var userId string
        var userName string
        userOld, exist := ah.UserStore.GetUser(loginRequest.UserName)

        if !exist </span><span class="cov0" title="0">{
                logger.Error.Println("User doesnt exist: ", loginRequest.UserName)
                userNew, err := ah.UserStore.AddUser(loginRequest.UserName)
                logger.Info.Println("User was added: ", userNew.UserName)
                if handleError(w, err, http.StatusBadRequest, "error add user") </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">userId = userNew.UserId.String()
                userName = userNew.UserName</span>
        } else<span class="cov0" title="0"> {
                userId = userOld.UserId.String()
                userName = userOld.UserName
        }</span>
        <span class="cov0" title="0">logger.Error.Println("Found user: ", loginRequest.UserName)

        http.SetCookie(w, &amp;http.Cookie{
                Name:     "Authorization",
                Value:    userId,
                MaxAge:   600,
                SameSite: http.SameSiteStrictMode,

                // SameSite: http.SameSiteDefaultMode,
                // Secure:   true,
        })

        http.SetCookie(w, &amp;http.Cookie{
                Name:     "UserName",
                Value:    userName,
                MaxAge:   600,
                SameSite: http.SameSiteStrictMode,
        })

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Login successful"})</span>
}

func (h *AuthHandler) LogoutHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Clear UserName cookie
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "UserName",
                Value:    "",
                Path:     "/",
                MaxAge:   -1,
                HttpOnly: false,
                Secure:   true, // Set to true if using HTTPS
                SameSite: http.SameSiteStrictMode,
        })

        // Clear Authorization cookie
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "Authorization",
                Value:    "",
                Path:     "/",
                MaxAge:   -1,
                HttpOnly: true, // Keep this true for security
                Secure:   true, // Set to true if using HTTPS
                SameSite: http.SameSiteStrictMode,
        })

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "Logout successful"})
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package controller

import (
        "context"
        "net/http"
)

type HTTPServer interface {
        ListenAndServe(addr string, handler http.Handler) error
        Shutdown(ctx context.Context) error
}

type RealHTTPServer struct {
        server *http.Server
}

func (s *RealHTTPServer) ListenAndServe(addr string, handler http.Handler) error <span class="cov0" title="0">{

        return http.ListenAndServe(addr, handler)
}</span>

func (s *RealHTTPServer) Shutdown(ctx context.Context) error <span class="cov0" title="0">{

        return s.server.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package controller

import (
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/zhekagigs/golang_todo/internal"
        "github.com/zhekagigs/golang_todo/logger"
        "github.com/zhekagigs/golang_todo/view"
)

type TaskRenderHandler struct {
        service  internal.TaskServiceInterface
        renderer view.Renderer
}

func handleError(w http.ResponseWriter, err error, status int, message string) bool <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                if err == internal.ErrNotFound </span><span class="cov0" title="0">{
                        logger.Error.Printf("Task not found: %s", message)
                        http.Error(w, "Task not found", http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> {
                        logger.Error.Printf("%s: %v", message, err)
                        if message == "" </span><span class="cov0" title="0">{
                                message = err.Error()
                        }</span>
                        <span class="cov0" title="0">http.Error(w, message, status)</span>
                }

                <span class="cov0" title="0">return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func getTaskIdFromQuery(r *http.Request) (int, error) <span class="cov8" title="1">{
        taskIDStr := r.URL.Query().Get("id")
        if taskIDStr == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("missing Task ID")
        }</span>
        <span class="cov8" title="1">return strconv.Atoi(taskIDStr)</span>
}

func NewTaskRenderHandler(service internal.TaskServiceInterface, renderer view.Renderer) *TaskRenderHandler <span class="cov8" title="1">{
        return &amp;TaskRenderHandler{service: service, renderer: renderer}
}</span>

func (h *TaskRenderHandler) HandleTaskListRead(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">tasks := h.service.Read()

        err := h.renderer.RenderTaskList(w, tasks)
        if handleError(w, err, http.StatusInternalServerError, "") </span><span class="cov0" title="0">{
                return
        }</span>
}

func (h *TaskRenderHandler) HandleTaskCreate(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        err := h.renderer.RenderCreateForm(w)
        handleError(w, err, http.StatusInternalServerError, "")
        return
}</span>

func (h *TaskRenderHandler) HandleTaskUpdate(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        logger.Info.Printf("Handling %s request for task update from %s", r.Method, r.RemoteAddr)

        taskID, err := getTaskIdFromQuery(r)
        if handleError(w, err, http.StatusBadRequest, "Invalid task ID") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                h.handleGetTaskUpdate(w, taskID)</span>
        case http.MethodPost:<span class="cov8" title="1">
                h.handlePostTaskUpdate(w, r, taskID)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

func (h *TaskRenderHandler) handleGetTaskUpdate(w http.ResponseWriter, taskID int) <span class="cov8" title="1">{
        task, err := h.service.FindTaskById(taskID)
        if handleError(w, err, http.StatusNotFound, "Task not found") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">err = h.renderer.RenderTaskUpdate(w, task)
        handleError(w, err, http.StatusInternalServerError, "Error rendering update form")</span>
}

func (h *TaskRenderHandler) handlePostTaskUpdate(w http.ResponseWriter, r *http.Request, taskID int) <span class="cov8" title="1">{
        update, err := ExtractFormValues(r)
        if handleError(w, err, http.StatusBadRequest, "Invalid form data") </span><span class="cov0" title="0">{
                return
        }</span>

        // logger.Info.Printf("Updating task with ID: %d", taskID)
        <span class="cov8" title="1">err = h.service.PartialUpdateTask(taskID, update)
        if handleError(w, err, http.StatusInternalServerError, "Failed to update task") </span><span class="cov0" title="0">{
                return
        }</span>

        // logger.Info.Printf("Successfully updated task with ID: %d", taskID)
        <span class="cov8" title="1">http.Redirect(w, r, "/tasks", http.StatusSeeOther)</span>
}

func (h *TaskRenderHandler) HandleTaskDelete(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // logger.Info.Printf("Handling %s request for task deletion from %s", r.Method, r.RemoteAddr)
        if r.Method != http.MethodDelete </span><span class="cov0" title="0">{
                logger.Error.Printf("Method not allowed: %s", r.Method)
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov8" title="1">taskID, err := getTaskIdFromQuery(r)
        err = h.service.DeleteTask(taskID)
        if handleError(w, err, http.StatusInternalServerError, fmt.Sprint(taskID)) </span><span class="cov0" title="0">{
                return
        }</span>

        // logger.Info.Printf("Successfully deleted task with ID: %d", taskID)
        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)</span>
}

func ExtractFormValues(r *http.Request) (*internal.TaskOptional, error) <span class="cov8" title="1">{
        // logger.Info.Println("Extracting form values")

        var errs []error
        addErr := func(err error, msg string) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("%s: %w", msg, err))
                        logger.Error.Printf("%s: %v", msg, err)
                }</span>
        }
        <span class="cov8" title="1">checkErr := func(err error, msg string) </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        addErr(err, msg)
                }</span>
        }
        <span class="cov8" title="1">msg := r.FormValue("msg")

        category, err := strconv.Atoi(r.FormValue("category"))
        checkErr(err, "Invalid category")

        dateString := r.FormValue("plannedAt")
        var plannedAt *internal.CustomTime
        if dateString != "" </span><span class="cov8" title="1">{
                plannedData, err := time.Parse("2006-01-02T15:04", dateString)
                plannedAt = internal.TimePtr(plannedData)
                checkErr(err, "invalid planned time")
        }</span> else<span class="cov0" title="0"> {
                plannedAt = nil
        }</span>

        <span class="cov8" title="1">var done *bool
        doneValue := r.FormValue("done")
        if doneValue != "" </span><span class="cov8" title="1">{
                doneBool, err := strconv.ParseBool(doneValue)
                done = internal.BoolPtr(doneBool)
                checkErr(err, "invalid done value")
        }</span> else<span class="cov8" title="1"> {
                done = nil
        }</span>

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                logger.Error.Printf("Form value errors: %v", errs)
                return nil, fmt.Errorf("form value errors: %v", errs)
        }</span>
        <span class="cov8" title="1">update := &amp;internal.TaskOptional{
                Done:      done,
                Msg:       internal.StringPtr(msg),
                Category:  (*internal.TaskCategory)(&amp;category),
                PlannedAt: plannedAt,
        }
        return update, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package internal

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/zhekagigs/golang_todo/users"
)

const TASK_TIME_FORMAT = "2006-01-02 15:04"

var jsonMarshal = json.MarshalIndent //for monkey patching mock

// error definitions
var (
        ErrNotFound = errors.New("not found")
)

type InvalidCategoryError struct {
        Category TaskCategory
}

func (e *InvalidCategoryError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("invalid task category: %v", e.Category)
}</span>

type EmptyTaskValueError struct{}

func (e *EmptyTaskValueError) Error() string <span class="cov0" title="0">{
        return "task value cannot be empty"
}</span>

type PastPlannedTimeError struct {
        PlannedTime time.Time
}

func (e *PastPlannedTimeError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("planned time %v is in the past", e.PlannedTime)
}</span>

type TaskCategory int

const (
        Brewing TaskCategory = iota
        Marketing
        Logistics
        Quality
)

func (tc TaskCategory) String() string <span class="cov8" title="1">{
        return [...]string{"Brewing", "Marketing", "Logistics", "Quality"}[tc]
}</span>

type Task struct {
        Id        int
        Msg       string
        Category  TaskCategory
        Done      bool
        CreatedAt time.Time
        PlannedAt time.Time
        CreatedBy users.User
}

func NewTask(id int, task string, category TaskCategory, plannedAt time.Time, user *users.User) Task <span class="cov8" title="1">{
        if user == nil </span><span class="cov8" title="1">{
                user = &amp;users.User{UserName: "Team"}
        }</span>
        <span class="cov8" title="1">return Task{
                Id:        id,
                Msg:       task,
                Category:  category,
                Done:      false,
                CreatedAt: timeNow().Round(0),
                PlannedAt: plannedAt.Round(0),
                CreatedBy: *user,
        }</span>
}

const (
        colorReset  = "\033[0m"
        colorRed    = "\033[31m"
        colorGreen  = "\033[32m"
        colorYellow = "\033[33m"
        colorBlue   = "\033[34m"
        colorPurple = "\033[35m"
        colorCyan   = "\033[36m"
        colorWhite  = "\033[37m"
)

func (t *Task) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("id:"+colorPurple+"%d,"+colorReset+colorBlue+"[%s] "+colorReset+colorCyan+"%s,"+colorReset+"\ncreated: %s,\nplanned: %s, \nfinished: %v",
                t.Id,
                t.Category.String(),
                t.Msg,
                formatDatetime(t.CreatedAt),
                formatDatetime(t.PlannedAt),
                t.Done)
}</span>

func PrintTasks(out io.Writer, tasks ...Task) <span class="cov0" title="0">{
        for _, task := range tasks </span><span class="cov0" title="0">{
                fmt.Fprintln(out, task.String()+"\n")
        }</span>
}

func WriteToJson(filePath string, tasks ...Task) error <span class="cov8" title="1">{
        if !strings.HasSuffix(filePath, ".json") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid file extension: %s. Expected a .json file", filePath)
        }</span>

        <span class="cov8" title="1">data, err := jsonMarshal(tasks, "", "  ")
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to marshal tasks: %w", err)
        }</span>

        <span class="cov8" title="1">err = os.WriteFile(filePath, data, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to a file '%s': %w", filePath, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ReadTasksFromJSON(filePath string) ([]Task, error) <span class="cov8" title="1">{
        if err := validateJSONFile(filePath); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read file '%s': %w", filePath, err)
        }</span>

        <span class="cov8" title="1">return UnmarshalTasks(data)</span>
}

func UnmarshalTasks(data []byte) ([]Task, error) <span class="cov8" title="1">{
        var tasks []Task
        if err := json.Unmarshal(data, &amp;tasks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>
        <span class="cov8" title="1">return tasks, nil</span>
}

func UnmarshalTask(data []byte) (*Task, error) <span class="cov0" title="0">{
        var task Task
        if err := json.Unmarshal(data, &amp;task); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;task, nil</span>
}

func validateJSONFile(filePath string) error <span class="cov8" title="1">{
        ext := filepath.Ext(filePath)
        if ext != ".json" </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid file extension: %s. Expected a .json file", filePath)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package internal

import (
        "errors"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/zhekagigs/golang_todo/users"
)

const (
        TimeFormat = "2006-01-02T15:04:05Z07:00"
)

var ErrTimeNilPointer = errors.New("time: nil pointer")

type TaskOptional struct {
        Done      *bool         `json:"done"`
        Msg       *string       `json:"msg"`
        Category  *TaskCategory `json:"category"`
        PlannedAt *CustomTime   `json:"plannedAt"`
        CreatedBy *users.User   `json:"createdBy"`
        // trackerId uuid.UUID
}

func AdapterTaskOptional(task Task) TaskOptional <span class="cov0" title="0">{
        custmTime, err := NewCustomTime(&amp;task.PlannedAt)
        if err != nil &amp;&amp; err != ErrTimeNilPointer </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return TaskOptional{
                Done:      &amp;task.Done,
                Msg:       &amp;task.Msg,
                Category:  &amp;task.Category,
                PlannedAt: custmTime,
        }</span>
}

type CustomTime struct {
        Time time.Time
}

func NewCustomTime(timePtr *time.Time) (*CustomTime, error) <span class="cov0" title="0">{
        if timePtr == nil </span><span class="cov0" title="0">{
                return nil, ErrTimeNilPointer
        }</span> else<span class="cov0" title="0"> {
                return &amp;CustomTime{Time: *timePtr}, nil
        }</span>
}

func (ct *CustomTime) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        s := strings.Trim(string(b), "\"")
        if s == "null" </span><span class="cov0" title="0">{
                ct.Time = time.Time{}
                return nil
        }</span>
        <span class="cov0" title="0">t, err := time.Parse(TimeFormat, s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ct.Time = t
        return nil</span>
}

func (ct *CustomTime) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        if ct.Time.IsZero() </span><span class="cov0" title="0">{
                return []byte("null"), nil
        }</span>
        <span class="cov0" title="0">return []byte(fmt.Sprintf("\"%s\"", ct.Time.Format(TimeFormat))), nil</span>
}

func (ct *CustomTime) AsTime() time.Time <span class="cov0" title="0">{
        return ct.Time
}</span>

// mainly to mock test
type TaskServiceInterface interface {
        Read() []Task
        CreateTask(TaskOptional) *Task
        FindTaskById(int) (*Task, error)
        PartialUpdateTask(int, *TaskOptional) error
        DeleteTask(int) error
}

// implements TaskService interface
type TaskHolder struct {
        latestId  int
        Tasks     []Task
        DiskPath  string
        TasksPipe chan Task
        sync.Mutex
}

func NewTaskHolder(diskPath string) *TaskHolder <span class="cov8" title="1">{
        return &amp;TaskHolder{DiskPath: diskPath}
}</span>

func (t *TaskHolder) Read() []Task <span class="cov8" title="1">{
        return append([]Task(nil), t.Tasks...)
}</span>

// returns latestId and len of tasks
func (t *TaskHolder) Count() (int, int) <span class="cov0" title="0">{
        return t.latestId, len(t.Tasks)
}</span>

func (t *TaskHolder) Add(task Task) <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()
        t.latestId++
        // if task.Id &lt; t.latestId {
        //         task.Id = t.latestId
        // }
        t.Tasks = append(t.Tasks, task)

}</span>

func (t *TaskHolder) CreateTask(update TaskOptional) *Task <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()
        t.latestId++

        var msg string
        if update.Msg != nil </span><span class="cov8" title="1">{
                msg = *update.Msg
        }</span>

        <span class="cov8" title="1">var category TaskCategory
        if update.Category != nil </span><span class="cov8" title="1">{
                category = *update.Category
        }</span>

        <span class="cov8" title="1">var plannedAt time.Time
        if update.PlannedAt != nil </span><span class="cov8" title="1">{
                plannedAt = update.PlannedAt.Time
        }</span>

        <span class="cov8" title="1">task := NewTask(t.latestId, msg, category, plannedAt, update.CreatedBy)
        t.Tasks = append(t.Tasks, task)
        return &amp;task</span>
}

func (t *TaskHolder) FindTaskById(taskId int) (*Task, error) <span class="cov8" title="1">{

        for i := range t.Tasks </span><span class="cov8" title="1">{
                if t.Tasks[i].Id == taskId </span><span class="cov8" title="1">{
                        return &amp;t.Tasks[i], nil
                }</span>
        }
        <span class="cov8" title="1">return nil, ErrNotFound</span>
}

func (t *TaskHolder) PartialUpdateTask(taskId int, update *TaskOptional) error <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()
        task, err := t.FindTaskById(taskId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if update.Done != nil </span><span class="cov8" title="1">{
                task.Done = *update.Done
        }</span>

        <span class="cov8" title="1">if update.Msg != nil </span><span class="cov8" title="1">{
                if len(*update.Msg) == 0 </span><span class="cov8" title="1">{
                        return &amp;EmptyTaskValueError{}
                }</span>
                <span class="cov8" title="1">task.Msg = *update.Msg</span>
        }

        <span class="cov8" title="1">if update.Category != nil </span><span class="cov8" title="1">{
                if !isValidTaskCategory(*update.Category) </span><span class="cov8" title="1">{
                        return &amp;InvalidCategoryError{Category: *update.Category}
                }</span>
                <span class="cov8" title="1">task.Category = *update.Category</span>
        }

        <span class="cov8" title="1">if update.PlannedAt != nil </span><span class="cov8" title="1">{
                if update.PlannedAt.Time.Before(time.Now()) </span><span class="cov8" title="1">{
                        return &amp;PastPlannedTimeError{PlannedTime: *&amp;update.PlannedAt.Time}
                }</span>
                <span class="cov8" title="1">task.PlannedAt = *&amp;update.PlannedAt.Time</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (t *TaskHolder) DeleteTask(taskId int) error <span class="cov8" title="1">{
        t.Lock()
        defer t.Unlock()
        index := -1
        topId := -1
        for i, task := range t.Tasks </span><span class="cov8" title="1">{
                if task.Id == taskId </span><span class="cov8" title="1">{
                        index = i

                }</span>
                <span class="cov8" title="1">if task.Id &gt; topId </span><span class="cov8" title="1">{
                        topId = task.Id
                }</span>
        }

        <span class="cov8" title="1">if index == -1 </span><span class="cov8" title="1">{
                return fmt.Errorf("task with ID %d not found", taskId)
        }</span>

        // deletedIndex = t.Tasks[index]
        <span class="cov8" title="1">t.Tasks = append(t.Tasks[:index], t.Tasks[index+1:]...)

        return nil</span>
}

func (t *TaskHolder) SearchTaskByWord(word string) ([]Task, error) <span class="cov0" title="0">{
        var matches []Task
        for _, task := range t.Tasks </span><span class="cov0" title="0">{
                if strings.Contains(task.Msg, word) </span><span class="cov0" title="0">{
                        matches = append(matches, task)
                }</span>
        }
        <span class="cov0" title="0">return matches, nil</span>
}

func isValidTaskCategory(category TaskCategory) bool <span class="cov8" title="1">{
        return Brewing &lt;= category &amp;&amp; category &lt;= Quality
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package internal

type ConcurrentTaskService struct {
        TaskHolder   *TaskHolder
        taskRequests chan&lt;- TaskRequest
        results      &lt;-chan TaskResult
        workerPool   WorkerPool
}

func NewConcurrentTaskService(t *TaskHolder) *ConcurrentTaskService <span class="cov0" title="0">{
        // fmt.Println("Init NewConcurrentTaskService")
        taskRequests := make(chan TaskRequest)
        results := make(chan TaskResult)
        pool := NewWorkerPool(5, t, taskRequests, results)
        service := &amp;ConcurrentTaskService{
                TaskHolder:   t,
                taskRequests: taskRequests,
                results:      results,
                workerPool:   pool,
        }
        service.workerPool.Start()

        return service
}</span>

func (t *ConcurrentTaskService) CloseAll() <span class="cov0" title="0">{
        // close(t.results)
        close(t.taskRequests)

}</span>

func (t *ConcurrentTaskService) CreateTask(task TaskOptional) *Task <span class="cov0" title="0">{
        // t.taskRequests &lt;- TaskRequest{Operation: "CREATE", Task: task}
        // result := &lt;-t.results

        return t.TaskHolder.CreateTask(task)
}</span>

func (t *ConcurrentTaskService) Add(task Task) <span class="cov0" title="0">{
        t.TaskHolder.Add(task)
}</span>

func (t *ConcurrentTaskService) FindTaskById(taskId int) (*Task, error) <span class="cov0" title="0">{
        return t.TaskHolder.FindTaskById(taskId)
}</span>

func (t *ConcurrentTaskService) PartialUpdateTask(taskId int, update *TaskOptional) error <span class="cov0" title="0">{
        return t.TaskHolder.PartialUpdateTask(taskId, update)
}</span>

func (t *ConcurrentTaskService) DeleteTask(taskId int) error <span class="cov0" title="0">{
        return t.TaskHolder.DeleteTask(taskId)
}</span>

// returns latestId and len of tasks
func (t *ConcurrentTaskService) Count() (int, int) <span class="cov0" title="0">{
        return t.TaskHolder.Count()
}</span>

func (t *ConcurrentTaskService) Read() []Task <span class="cov0" title="0">{
        return t.TaskHolder.Read()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package internal

import (
        "bytes"
        "io"
        "os"
        "testing"
        "time"

        "github.com/google/uuid"
        "github.com/zhekagigs/golang_todo/users"
)

var MockTime = time.Date(2023, 7, 23, 12, 0, 0, 0, time.UTC).Truncate(0)

func ProvideMockUserID() uuid.UUID <span class="cov8" title="1">{
        mockUserId, err := uuid.Parse("00a1c791-f200-42b0-b7e3-2eddb2afcc7a")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return mockUserId</span>
}

func ProvideMocktimeNow(t *testing.T) func() time.Time <span class="cov8" title="1">{
        originalTimeNow := timeNow
        t.Cleanup(func() </span><span class="cov8" title="1">{
                timeNow = originalTimeNow
        }</span>)
        <span class="cov8" title="1">return func() time.Time </span><span class="cov8" title="1">{
                return MockTime
        }</span>
}

func ProvideMockUser() *users.User <span class="cov8" title="1">{
        return &amp;users.User{UserName: "Admin", UserId: ProvideMockUserID()}
}</span>

func ProvideTask(t *testing.T) Task <span class="cov8" title="1">{
        return NewTask(1, "task_my_task", 1, MockTime, ProvideMockUser())
}</span>

func ProvideTaskHolder() *TaskHolder <span class="cov8" title="1">{
        th := NewTaskHolder("resources/cli_disk_test.json")
        updt := TaskOptional{
                nil,
                StringPtr("Initial Task"),
                CategoryPtr(Brewing),
                TimePtr(time.Now().Add(24 * time.Hour)),
                ProvideMockUser(),
        }

        th.CreateTask(updt)
        return th
}</span>

func ProvideTaskHolderWithPath(path string) *TaskHolder <span class="cov8" title="1">{
        th := NewTaskHolder(path)
        updt := TaskOptional{
                nil,
                StringPtr("Initial Task"),
                CategoryPtr(Brewing),
                TimePtr(time.Now().Add(24 * time.Hour)),
                ProvideMockUser(),
        }
        th.CreateTask(updt)
        return th
}</span>
func MockNewTaskHolder(diskPath string) *TaskHolder <span class="cov8" title="1">{

        th := NewTaskHolder("resources/cli_disk_test.json")
        updt := TaskOptional{
                nil,
                StringPtr("Initial Task"),
                CategoryPtr(Brewing),
                TimePtr(time.Now().Add(24 * time.Hour)),
                ProvideMockUser(),
        }
        th.CreateTask(updt)
        return th
}</span>

func ReadCapturedStdout(r *os.File) string <span class="cov8" title="1">{
        var buf bytes.Buffer
        io.Copy(&amp;buf, r)
        output := buf.String()
        return output
}</span>

func WriteToCapturedStdin(write *os.File, cmnds []string) <span class="cov0" title="0">{
        time.Sleep(100 * time.Millisecond)
        for _, cmnd := range cmnds </span><span class="cov0" title="0">{
                write.Write([]byte(cmnd))
                time.Sleep(100 * time.Millisecond)
        }</span>
}

// Restore after capturing
func RestoreStdout(w *os.File, oldStdout *os.File) <span class="cov8" title="1">{
        w.Close()
        os.Stdout = oldStdout
}</span>

// Restore after capturing
func RestoreStdin(r *os.File, oldStdin *os.File) <span class="cov8" title="1">{
        r.Close()
        os.Stdin = oldStdin
}</span>

// Capture stdout. DON'T FORGET TO RESTORE!
func CaptureStdout() (oldStdout *os.File, read *os.File, write *os.File) <span class="cov8" title="1">{
        oldStdout = os.Stdout
        read, write, _ = os.Pipe()
        os.Stdout = write
        return
}</span>

// Capture stdin. DON'T FORGET TO RESTORE!
func CaptureStdin() (oldStdin *os.File, read *os.File, write *os.File) <span class="cov8" title="1">{
        oldStdin = os.Stdin
        read, write, _ = os.Pipe()
        os.Stdin = read
        return
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package internal

import (
        "embed"
        "fmt"
        "io/fs"
        "math/rand"
        "strings"
        "time"
)

//go:embed resources
var resourcesFiles embed.FS

var timeNow = time.Now

func check(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
}

func formatDatetime(t time.Time) string <span class="cov8" title="1">{
        return t.Format("Monday, January 2, 2006 at 15:04")
}</span>

func GenerateRandomTasks(count int) []Task <span class="cov8" title="1">{
        brewingVerbs := []string{"Brew", "Ferment", "Bottle", "Label", "Clean", "Inspect", "Order", "Taste"}
        adjectives := []string{"Hoppy", "Malty", "Crisp", "Smooth", "Tangy", "Barrel-aged", "Experimental", "Funky", "Juicy", "Hazy", "Robust", "Refreshing"}
        beerTypes := []string{"IPA", "Stout", "Lager", "Wheat Beer", "Pale Ale", "Porter", "Sour", "Seasonal Batch"}
        ingredients := []string{"Hops", "Malt", "Yeast", "Fruit puree", "Spices", "Coffee beans", "Cocoa nibs", "Oak chips"}
        marketingTasks := []string{"Design new label", "Plan social media campaign", "Organize tasting event", "Create promotional video", "Update website", "Develop brand partnership", "Analyze market trends", "Conduct customer survey"}
        logisticsTasks := []string{"Schedule delivery route", "Inventory check", "Restock supplies", "Maintain delivery vehicles", "Optimize warehouse layout", "Negotiate with suppliers", "Update inventory management system", "Coordinate with distributors"}
        qualityTasks := []string{"Conduct sensory analysis", "Calibrate testing equipment", "Review quality control procedures", "Train staff on quality standards", "Perform microbiological testing", "Update quality assurance documentation", "Conduct supplier quality audit", "Implement new quality control measure"}

        tasks := make([]Task, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                var taskValue string
                var category TaskCategory
                x := rand.Intn(5)
                switch x </span>{
                case 0:<span class="cov8" title="1">
                        verb := brewingVerbs[rand.Intn(len(brewingVerbs))]
                        adj := adjectives[rand.Intn(len(adjectives))]
                        noun := beerTypes[rand.Intn(len(beerTypes))]
                        taskValue = strings.Join([]string{verb, adj, noun}, " ")
                        category = Brewing</span>
                case 1:<span class="cov8" title="1">
                        verb := "Process"
                        if rand.Intn(2) == 0 </span><span class="cov0" title="0">{
                                verb = "Order"
                        }</span>
                        <span class="cov8" title="1">ingredient := ingredients[rand.Intn(len(ingredients))]
                        quantity := rand.Intn(500) + 1 // 1 to 500
                        unit := "kg"
                        if rand.Intn(2) == 0 </span><span class="cov0" title="0">{
                                unit = "lbs"
                        }</span>
                        <span class="cov8" title="1">taskValue = fmt.Sprintf("%s %d %s of %s", verb, quantity, unit, ingredient)
                        category = Brewing</span>
                case 2:<span class="cov8" title="1">
                        taskValue = marketingTasks[rand.Intn(len(marketingTasks))]
                        category = Marketing</span>
                case 3:<span class="cov0" title="0">
                        taskValue = logisticsTasks[rand.Intn(len(logisticsTasks))]
                        category = Logistics</span>
                case 4:<span class="cov8" title="1">
                        taskValue = qualityTasks[rand.Intn(len(qualityTasks))]
                        category = Quality</span>

                }
                <span class="cov8" title="1">plannedAt := time.Now().Add(time.Duration(rand.Intn(24*30)) * time.Hour)
                newTask := NewTask(i, taskValue, category, plannedAt, ProvideMockUser())
                tasks[i] = newTask</span>
        }
        <span class="cov8" title="1">return tasks</span>
}

func BeerAscii() string <span class="cov8" title="1">{
        data, err := fs.ReadFile(resourcesFiles, "resources/beer.txt")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("error happened while reading beer logo: ", err)
                return ""
        }</span>
        <span class="cov8" title="1">return string(data)</span>
}

func StringPtr(s string) *string <span class="cov8" title="1">{
        if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;s</span>
}

func CategoryPtr(c TaskCategory) *TaskCategory <span class="cov8" title="1">{
        return &amp;c
}</span>

func TimePtr(t time.Time) *CustomTime <span class="cov8" title="1">{
        return &amp;CustomTime{t}
}</span>

func BoolPtr(b bool) *bool <span class="cov0" title="0">{
        return &amp;b
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package internal

import (
        "fmt"

        "github.com/google/uuid"
)

type TaskRequest struct {
        Operation  string
        Task       TaskOptional
        TaskId     int
        trackingId uuid.UUID
}

type TaskResult struct {
        Task  *Task
        Error error
}

type Worker struct {
        id         int
        taskHolder *TaskHolder
        request    &lt;-chan TaskRequest
        result     chan&lt;- TaskResult
        quit       chan bool
}

type WorkerPool struct {
        workers []Worker
        // wg      sync.WaitGroup
}

func (w *Worker) Start() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case req, ok := &lt;-w.request:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">result := w.processRequest(req)
                        w.result &lt;- result</span>
                case &lt;-w.quit:<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (w *Worker) Stop() <span class="cov0" title="0">{
        close(w.quit)
}</span>

func (w *Worker) processRequest(req TaskRequest) TaskResult <span class="cov0" title="0">{
        switch req.Operation </span>{
        case "CREATE":<span class="cov0" title="0">
                // fmt.Println("Worker calls holder to create task", w.id)
                task := w.taskHolder.CreateTask(req.Task)
                return TaskResult{Task: task}</span>
        default:<span class="cov0" title="0">
                return TaskResult{Error: fmt.Errorf("unknown operation: %s", req.Operation)}</span>
        }
}

func NewWorkerPool(numWorkers int, taskHolder *TaskHolder, taskRequests &lt;-chan TaskRequest, taskResponse chan&lt;- TaskResult) WorkerPool <span class="cov0" title="0">{
        // fmt.Println("Init NewWorkerPool")
        var workers []Worker
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov0" title="0">{
                workers = append(workers, Worker{
                        id:         i,
                        taskHolder: taskHolder,
                        request:    taskRequests,
                        result:     taskResponse,
                        quit:       make(chan bool),
                })
        }</span>
        <span class="cov0" title="0">return WorkerPool{ // composite literal
                workers: workers,
        }</span>
}

func (wp *WorkerPool) Start() <span class="cov0" title="0">{
        for i := range wp.workers </span><span class="cov0" title="0">{
                go wp.workers[i].Start()
        }</span>
}

func (wp *WorkerPool) Close() <span class="cov0" title="0">{
        for _, worker := range wp.workers </span><span class="cov0" title="0">{
                worker.Stop()
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package logger

import (
        "log"
        "os"
)

var (
        Info  *log.Logger
        Error *log.Logger
)

func init() <span class="cov8" title="1">{
        // Set up Info logger
        Info = log.New(os.Stdout, "INFO: ", log.Ldate|log.Ltime|log.Lshortfile)

        // Set up Error logger
        Error = log.New(os.Stderr, "ERROR: ", log.Ldate|log.Ltime|log.Lshortfile)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package middleware

import (
        "context"
        "errors"
        "net/http"
        "strings"
        "time"

        "github.com/zhekagigs/golang_todo/logger"
)

type LoggingMiddleware struct {
        Next http.Handler
}

func (m LoggingMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        start := time.Now()

        crw := &amp;customResponseWriter{ResponseWriter: w} // TODO remove

        m.Next.ServeHTTP(crw, r)

        duration := time.Since(start)

        logger.Info.Printf(
                "Method: %s, Path: %s, Status: %d, Duration: %v",
                r.Method,
                r.URL.Path,
                crw.status,
                duration,
        )
}</span>

type userKey struct{}

// a real implementation would be signed to make sure
// the user didn't spoof their identity
func extractUser(req *http.Request) (string, error) <span class="cov8" title="1">{
        if strings.Contains(req.URL.Path, "api") </span><span class="cov8" title="1">{
                identityId, ok := req.Header["Authorization"]
                if !ok || len(identityId) == 0 || identityId[0] == "" </span><span class="cov0" title="0">{
                        return "", errors.New("no identity header found")
                }</span>
                <span class="cov8" title="1">return identityId[0], nil</span>
        } else<span class="cov0" title="0"> {
                return extractUserFromCookie(req)
        }</span>
}

func extractUserFromCookie(req *http.Request) (string, error) <span class="cov0" title="0">{
        identityId, err := req.Cookie("Authorization")
        if err != nil || len(identityId.Value) == 0 </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return identityId.Value, nil</span>
}

func AuthMiddleware(next http.HandlerFunc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{

                userVal, err := extractUser(r)

                if err != nil || userVal == "" </span><span class="cov0" title="0">{
                        logger.Error.Println("error extacting user id", err)
                        w.Write([]byte("&lt;div&gt;Please go back and login&lt;/div&gt; &lt;a href=/tasks&gt; Main Page&lt;/a&gt;"))
                        // http.Redirect(w, r, "/tasks", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov8" title="1">ctx := r.Context()
                ctx = ContextWithUser(ctx, userVal)
                r = r.WithContext(ctx)
                next.ServeHTTP(w, r)</span>
        }
}

func ContextWithUser(ctx context.Context, user string) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, userKey{}, user)
}</span>

func UserFromContext(ctx context.Context) (string, bool) <span class="cov8" title="1">{
        user, ok := ctx.Value(userKey{}).(string)
        return user, ok
}</span>

type customResponseWriter struct {
        http.ResponseWriter
        status int
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package repository

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "time"

        "cloud.google.com/go/storage"
        "github.com/zhekagigs/golang_todo/internal"
        "github.com/zhekagigs/golang_todo/logger"
        "google.golang.org/api/option"
)

const (
        EnvGoogleAPIKey = "GOOGLE_API_KEY"
        EnvBucketName   = "GCS_BUCKET_NAME"
)

type TaskRepository interface {
        SaveTasks(tasks []internal.Task) error
        LoadTasks() ([]internal.Task, error)
}

type GCSRepository struct {
        bucketName  string
        objectName  string
        client      *storage.Client
        clientCtx   context.Context
        credentials string
}

type GCSConfig struct {
        BucketName string
        ObjectName string
        APIKey     string
}

// Get GCS configuration.
// Get credentials path.
// Initialize GCS repository.
func ConfigureRepo() (*GCSRepository, error) <span class="cov0" title="0">{
        ctx := context.Background()
        // Set up GCS environment variables for tests
        bucketName := "go-todo-app-json-storage"
        objectName := "test-tasks.json"

        os.Setenv("GCS_BUCKET_NAME", bucketName)
        os.Setenv("GCS_OBJECT_NAME", objectName)

        bucketName, objectName, err := GetGCSConfig()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error.Printf("Failed to get GCS config: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error.Printf("Failed to get home directory: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">credsPath := filepath.Join(homeDir, ".config", "gcloud", "application_default_credentials.json")
        if _, err := os.Stat(credsPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Printf("Credentials file not found at %s - run 'gcloud auth application-default login' first", credsPath)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">repo, err := NewGCSRepository(ctx, bucketName, objectName, credsPath)
        return repo, err</span>
}

func NewGCSRepository(ctx context.Context, bucketName, objectName, credentialsFile string) (*GCSRepository, error) <span class="cov8" title="1">{

        client, err := storage.NewClient(ctx, option.WithCredentialsFile(credentialsFile))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create storage client: %v", err)
        }</span>

        <span class="cov8" title="1">return &amp;GCSRepository{
                bucketName:  bucketName,
                objectName:  objectName,
                client:      client,
                clientCtx:   ctx,
                credentials: credentialsFile,
        }, nil</span>
}

func (r *GCSRepository) Close() error <span class="cov8" title="1">{
        return r.client.Close()
}</span>

// SaveTasks saves tasks to a JSON file in GCS bucket
func (r *GCSRepository) SaveTasks(tasks []internal.Task) error <span class="cov8" title="1">{
        bucket := r.client.Bucket(r.bucketName)
        obj := bucket.Object(r.objectName)

        // Create a new context with timeout for the upload operation
        ctx, cancel := context.WithTimeout(r.clientCtx, time.Minute)
        defer cancel()

        writer := obj.NewWriter(ctx)
        writer.ContentType = "application/json"

        // Marshal tasks to JSON
        data, err := json.MarshalIndent(tasks, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal tasks: %v", err)
        }</span>

        // Write data
        <span class="cov8" title="1">if _, err := writer.Write(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to GCS: %v", err)
        }</span>

        // Close writer
        <span class="cov8" title="1">if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close writer: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// LoadTasks loads tasks from a JSON file in GCS bucket
func (r *GCSRepository) LoadTasks() ([]internal.Task, error) <span class="cov8" title="1">{
        bucket := r.client.Bucket(r.bucketName)
        obj := bucket.Object(r.objectName)

        ctx, cancel := context.WithTimeout(r.clientCtx, time.Minute)
        defer cancel()

        reader, err := obj.NewReader(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if err == storage.ErrObjectNotExist </span><span class="cov8" title="1">{
                        return []internal.Task{}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to create reader: %v", err)</span>
        }
        <span class="cov8" title="1">defer reader.Close()

        data, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read from GCS: %v", err)
        }</span>

        <span class="cov8" title="1">var tasks []internal.Task
        if err := json.Unmarshal(data, &amp;tasks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal tasks: %v", err)
        }</span>
        <span class="cov8" title="1">fmt.Println(tasks)

        return tasks, nil</span>
}

// GetGCSConfig returns bucket configuration from environment variables
func GetGCSConfig() (string, string, error) <span class="cov8" title="1">{
        bucketName := os.Getenv("GCS_BUCKET_NAME")
        if bucketName == "" </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("GCS_BUCKET_NAME environment variable not set")
        }</span>

        <span class="cov8" title="1">objectName := os.Getenv("GCS_OBJECT_NAME")
        if objectName == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("no gcs object provided")
        }</span>

        <span class="cov8" title="1">return bucketName, objectName, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package users

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "sync"

        "github.com/google/uuid"
)

type User struct {
        UserName string    `json:"userName"`
        UserId   uuid.UUID `json:"userId"`
}

type UserStore struct {
        Users map[string]User `json:"users"`
        mu    sync.RWMutex
        file  string
}

func NewUserStore(file string) (*UserStore, error) <span class="cov8" title="1">{
        store := &amp;UserStore{
                Users: make(map[string]User),
                file:  file,
        }
        err := store.Load()
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return store, nil</span>
}

func (s *UserStore) Load() error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        data, err := os.ReadFile(s.file)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return json.Unmarshal(data, &amp;s.Users)</span>
}

func (s *UserStore) Save() error <span class="cov8" title="1">{

        data, err := json.MarshalIndent(s.Users, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return os.WriteFile(s.file, data, 0644)</span>
}

func (s *UserStore) AddUser(username string) (*User, error) <span class="cov8" title="1">{
        if username == "" </span><span class="cov8" title="1">{
                return nil, errors.New("user name can't be empty")
        }</span>
        <span class="cov8" title="1">if _, exists := s.Users[username]; exists </span><span class="cov8" title="1">{
                return nil, errors.New("user already exists")
        }</span>
        <span class="cov8" title="1">newUser := User{UserName: username, UserId: uuid.New()}
        s.Users[username] = newUser
        fmt.Println(s.Users)
        err := s.Save()
        return &amp;newUser, err</span>
}

func (s *UserStore) GetUser(username string) (User, bool) <span class="cov8" title="1">{
        user, exists := s.Users[username]
        return user, exists
}</span>
func (s *UserStore) GetUserById(userId string) (User, bool) <span class="cov8" title="1">{
        for _, v := range s.Users </span><span class="cov8" title="1">{
                if v.UserId.String() == userId </span><span class="cov8" title="1">{
                        return v, true
                }</span>
        }
        <span class="cov8" title="1">return User{}, false</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package view

import (
        "embed"
        "fmt"
        "html/template"
        "net/http"
        "strings"
        "time"

        "github.com/zhekagigs/golang_todo/internal"
        "github.com/zhekagigs/golang_todo/logger"
)

//go:embed templates/*.html
var templateFiles embed.FS

// type TemplateData struct {
//         Tasks []in.Task
// }

type Renderer interface {
        RenderTaskList(http.ResponseWriter, []internal.Task) error
        RenderCreateForm(http.ResponseWriter) error
        RenderTaskUpdate(http.ResponseWriter, *internal.Task) error
}

type TaskRenderer struct {
        templates *template.Template
}

type TaskListData struct {
        Tasks []internal.Task
}

func renderErrCheck(err error) error <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error rendering template: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func NewRenderer() (*TaskRenderer, error) <span class="cov8" title="1">{
        funcMap := template.FuncMap{
                "formatDate": func(t time.Time) string </span><span class="cov8" title="1">{
                        return t.Format("Jan 02, 2006 15:04")
                }</span>,
                "toLowerCase": strings.ToLower,
        }

        <span class="cov8" title="1">tmpl, err := template.New("").Funcs(funcMap).ParseFS(templateFiles, "templates/*.html")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;TaskRenderer{templates: tmpl}, nil</span>
}

func (r *TaskRenderer) RenderTaskList(w http.ResponseWriter, tasks []internal.Task) error <span class="cov8" title="1">{
        logger.Info.Printf("Rendering Task List")
        data := TaskListData{
                Tasks: tasks,
        }

        err := r.templates.ExecuteTemplate(w, "index.html", data)
        return renderErrCheck(err)
}</span>

func (r *TaskRenderer) RenderCreateForm(w http.ResponseWriter) error <span class="cov8" title="1">{
        err := r.templates.ExecuteTemplate(w, "create.html", nil)
        return renderErrCheck(err)
}</span>

func (r *TaskRenderer) RenderTaskUpdate(w http.ResponseWriter, task *internal.Task) error <span class="cov8" title="1">{
        logger.Info.Println("Rendering update task form")
        data := struct {
                Task *internal.Task
        }{
                Task: task,
        }
        err := r.templates.ExecuteTemplate(w, "update.html", data)
        return renderErrCheck(err)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
